### Makefile简介

 make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。

规则: 

1. 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。

2. 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。

3. 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。

包含：**显式规则、隐晦规则、变量定义、文件指示和注释**

1. 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。
2. 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。
3. 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。
4. 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。
5.  注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\#”。



### Makefile规则

target... : prerequisites...

​	commands

**target** 是目标文件，可以是**Object File**，也可以是执行文件，还可以是一个标签（Label）。

**prerequisites** 是生成target所需要的文件或目标。

**command** 也就是make生成target需要执行的命令。（任意的Shell命令）

常用变量：

$@ —— 目标文件

$^ —— 所有依赖文件

$< —— 第一个依赖文件

注意事项：

**反斜杠（\）**换行

缩进必须要用**tab**，不能使用空格

注释用 **#**



### make工作流程

`make`

`make -f makefile文件`

`include<filename>`

`-include<filename>` 忽略找不到的文件

使用make命令后：

1. make会在当前目录下找名字叫“Makefile”或“makefile”的文件。
2. 如果存在target，它会以找到的第一个target为目标。
3. 如果target对应的文件不存在，或者依赖的prerequisites文件修改时间晚于target文件生成时间。
4. 如果target依赖的文件不存在，那么make会在目前文件中寻找依赖文件的依赖性，根据找到的规则先生成依赖文件。

make的工作步骤：

1. 读入所有的Makefile。
2. 读入被include的其它Makefile。
3. 初始化文件中的变量。
4. 推导隐晦规则，并分析所有规则。
5. 为所有的目标文件创建依赖关系链。
6. 根据依赖关系，决定哪些目标要重新生成。
7. 执行生成命令。



### Makefile书写规则

规则包含两个部分，一个是**依赖关系**，一个是**生成目标的方法**。

**在Makefile中，规则的顺序是很重要的**，因为，**Makefile中只应该有一个最终目标**，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。