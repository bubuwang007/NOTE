# 序列类型 

有三种基本序列类型：list, tuple 和 range 对象。 为处理 [二进制数据](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 和 [文本字符串](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 而特别定制的附加序列类型会在专门的小节中描述。



# 通用序列操作

大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 [`collections.abc.Sequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.Sequence) ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。

此表按优先级升序列出了序列操作。 在表格中，*s* 和 *t* 是具有相同类型的序列，*n*, *i*, *j* 和 *k* 是整数而 *x* 是任何满足 *s* 所规定的类型和值限制的任意对象。

`in` 和 `not in` 操作具有与比较操作相同的优先级。 `+` (拼接) 和 `*` (重复) 操作具有与对应数值运算相同的优先级。

|         运算         |                            结果：                            |
| :------------------: | :----------------------------------------------------------: |
|       `x in s`       |  如果 *s* 中的某项等于 *x* 则结果为 `True`，否则为 `False`   |
|     `x not in s`     |  如果 *s* 中的某项等于 *x* 则结果为 `False`，否则为 `True`   |
|       `s + t`        |                      *s* 与 *t* 相拼接                       |
|     `s*n`或`n*s`     |               相当于 *s* 与自身进行 *n* 次拼接               |
|        `s[i]`        |                  *s* 的第 *i* 项，起始为 0                   |
|       `s[i:j]`       |                   *s* 从 *i* 到 *j* 的切片                   |
|      `s[i:j:k]`      |             *s* 从 *i* 到 *j* 步长为 *k* 的切片              |
|       `len(s)`       |                          *s* 的长度                          |
|       `min(s)`       |                         *s* 的最小项                         |
|       `max(s)`       |                         *s* 的最大项                         |
| `s.index(x[,i[,j]])` | *x* 在 *s* 中首次出现项的索引号（索引号在 *i* 或其后且在 *j* 之前） |
|     `s.count(x)`     |                  *x* 在 *s* 中出现的总次数                   |



# 不可变序列类型

不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 [`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash) 内置函数的支持。

这种支持允许不可变类型，例如 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 实例被用作 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 键，以及存储在 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 实例中。

尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。



# 可变序列类型

以下表格中的操作是在可变序列类型上定义的。 [`collections.abc.MutableSequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.MutableSequence) ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。

表格中的 *s* 是可变序列类型的实例，*t* 是任意可迭代对象，而 *x* 是符合对 *s* 所规定类型与值限制的任何对象 (例如，[`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 仅接受满足 `0 <= x <= 255` 值限制的整数)。

|           运算            |                            结果：                            | 备注 |
| :-----------------------: | :----------------------------------------------------------: | :--: |
|        `s[i] = x`         |                 将 *s* 的第 *i* 项替换为 *x*                 |      |
|       `s[i:j] = t`        |    将 *s* 从 *i* 到 *j* 的切片替换为可迭代对象 *t* 的内容    |      |
|       `del s[i:j]`        |                     等同于 `s[i:j] = []`                     |      |
|      `s[i:j:k] = t`       |            将 `s[i:j:k]` 的元素替换为 *t* 的元素             | (1)  |
|      `del s[i:j:k]`       |                从列表中移除 `s[i:j:k]` 的元素                |      |
|       `s.append(x)`       |  将 *x* 添加到序列的末尾 (等同于 `s[len(s):len(s)] = [x]`)   |      |
|        `s.clear()`        |           从 *s* 中移除所有项 (等同于 `del s[:]`)            | (5)  |
|        `s.copy()`         |              创建 *s* 的浅拷贝 (等同于 `s[:]`)               | (5)  |
| `s.extend(t)` 或 `s += t` | 用 *t* 的内容扩展 *s* (基本上等同于 `s[len(s):len(s)] = t`)  |      |
|         `s *= n`          |           使用 *s* 的内容重复 *n* 次来对其进行更新           | (6)  |
|     `s.insert(i, x)`      | 在由 *i* 给出的索引位置将 *x* 插入 *s* (等同于 `s[i:i] = [x]`) |      |
|  `s.pop()` or `s.pop(i)`  |          提取在 *i* 位置上的项，并将其从 *s* 中移除          | (2)  |
|       `s.remove(x)`       |          删除 *s* 中第一个 `s[i]` 等于 *x* 的项目。          | (3)  |
|       `s.reverse()`       |                   就地将列表中的元素逆序。                   | (4)  |

注释：

1. *t* 必须与它所替换的切片具有相同的长度。

2. 可选参数 *i* 默认为 `-1`，因此在默认情况下会移除并返回最后一项。

3. 当在 *s* 中找不到 *x* 时 `remove()` 操作会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

4. 当反转大尺寸序列时 `reverse()` 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。

5. 包括 `clear()` 和 `copy()` 是为了与不支持切片操作的可变容器 (例如 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 和 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set)) 的接口保持一致。 `copy()` 不是 [`collections.abc.MutableSequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.MutableSequence) ABC 的一部分，但大多数具体的可变序列类都提供了它。

   3.3 新版功能: `clear()` 和 `copy()` 方法。

6. *n* 值为一个整数，或是一个实现了 [`__index__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__) 的对象。 *n* 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 [通用序列操作](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 中有关 `s * n` 的说明。



# 列表

列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。

*class* `list`([*iterable*])

可以用多种方式构建列表：

- 使用一对方括号来表示空列表: `[]`
- 使用方括号，其中的项以逗号分隔: `[a]`, `[a, b, c]`
- 使用列表推导式: `[x for x in iterable]`
- 使用类型的构造器: `list()` 或 `list(iterable)`

构造器将构造一个列表，其中的项与 *iterable* 中的项具有相同的的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其它可迭代对象。 如果 *iterable* 已经是一个列表，将创建并返回其副本，类似于 `iterable[:]`。 例如，`list('abc')` 返回 `['a', 'b', 'c']` 而 `list( (1, 2, 3) )` 返回 `[1, 2, 3]`。 如果没有给出参数，构造器将创建一个空列表 `[]`。

其它许多操作也会产生列表，包括 [`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted) 内置函数。

列表实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 和 [可变](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-mutable) 序列的操作。 列表还额外提供了以下方法：

`sort`(***,* key=None*,* reverse=False*)

此方法会对列表进行原地排序，只使用 `<` 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。

[`sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 接受两个仅限以关键字形式传入的参数 ([仅限关键字参数](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#keyword-only-parameter)):

*key* 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 `key=str.lower`)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 `None` 表示直接对列表项排序而不计算一个单独的键值。

可以使用 [`functools.cmp_to_key()`](https://www.bookstack.cn/read/python-3.10.0-zh/428f88eb5e920558.md#functools.cmp_to_key) 将 2.x 风格的 *cmp* 函数转换为 *key* 函数。

*reverse* 为一个布尔值。 如果设为 `True`，则每个列表元素将按反向顺序比较进行排序。

当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 [`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted) 显示地请求一个新的已排序列表实例）。

[`sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再接薪级排序）。

**CPython implementation detail:** 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。



# 元组

元组是不可变序列，通常用于储存异构数据的多项集（例如由 [`enumerate()` 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 或 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 的实例）。

*class* `tuple`([*iterable*])

可以用多种方式构建元组：

- 使用一对圆括号来表示空元组: `()`
- 使用一个后缀的逗号来表示单元组: `a,` 或 `(a,)`
- 使用以逗号分隔的多个项: `a, b, c` or `(a, b, c)`
- 使用内置的 [`tuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple): `tuple()` 或 `tuple(iterable)`

构造器将构造一个元组，其中的项与 *iterable* 中的项具有相同的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其他可迭代对象。 如果 *iterable* 已经是一个元组，会不加改变地将其返回。 例如，`tuple('abc')` 返回 `('a', 'b', 'c')` 而 `tuple( [1, 2, 3] )` 返回 `(1, 2, 3)`。 如果没有给出参数，构造器将创建一个空元组 `()`。

请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，`f(a, b, c)` 是在调用函数时附带三个参数，而 `f((a, b, c))` 则是在调用函数时附带一个三元组。

元组实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的操作。

对于通过名称访问相比通过索引访问更清晰的异构数据多项集，[`collections.namedtuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#collections.namedtuple) 可能是比简单元组对象更为合适的选择。



# range 对象

[`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 类型表示不可变的数字序列，通常用于在 [`for`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#for) 循环中循环指定的次数。

*class* `range`(*stop*)

*class* `range`(*start*, *stop*[, *step*])

range 构造器的参数必须为整数（可以是内置的 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 或任何实现了 `__index__` 特殊方法的对象）。 如果省略 *step* 参数，其默认值为 `1`。 如果省略 *start* 参数，其默认值为 `0`，如果 *step* 为零则会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

如果 *step* 为正值，确定 range `r` 内容的公式为 `r[i] = start + step*i` 其中 `i >= 0` 且 `r[i] < stop`。

如果 *step* 为负值，确定 range 内容的公式仍然为 `r[i] = start + step*i`，但限制条件改为 `i >= 0` 且 `r[i] > stop`.

如果 `r[0]` 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。

元素绝对值大于 [`sys.maxsize`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.maxsize) 的 range 对象是被允许的，但某些特性 (例如 [`len()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#len)) 可能引发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。

一些 range 对象的例子:

~~~python
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(range(0, 30, 5))
[0, 5, 10, 15, 20, 25]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> list(range(0))
[]
>>> list(range(1, 0))
[]
~~~

range 对象实现了 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。

- `start`

  *start* 形参的值 (如果该形参未提供则为 `0`)

- `stop`

  *stop* 形参的值

- `step`

  *step* 形参的值 (如果该形参未提供则为 `1`)

[`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 类型相比常规 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 或 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 的优势在于一个 [`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 `start`, `stop` 和 `step` 值，并会根据需要计算具体单项或子范围的值）。

range 对象实现了 [`collections.abc.Sequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.Sequence) ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 (参见 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)):

~~~python
>>> r = range(0, 20, 2)
>>> r
range(0, 20, 2)
>>> 11 in r
False
>>> 10 in r
True
>>> r.index(10)
5
>>> r[5]
10
>>> r[:5]
range(0, 10, 2)
>>> r[-1]
18
~~~

使用 `==` 和 `!=` 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 [`start`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.start), [`stop`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.stop) 和 [`step`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.step) 属性，例如 `range(0) == range(2, 1, 3)` 而 `range(0, 3, 2) == range(0, 4, 2)`。）

在 3.2 版更改: 实现 Sequence ABC。 支持切片和负数索引。 使用 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象在固定时间内进行成员检测，而不是逐一迭代所有项。

在 3.3 版更改: 定义 ‘==’ 和 ‘!=’ 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。

3.3 新版功能: [`start`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.start), [`stop`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.stop) 和 [`step`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.step) 属性。

参见

- [linspace recipe](http://code.activestate.com/recipes/579000/) 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。



# 文本序列类型str

在 Python 中处理文本数据是使用 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 对象，也称为 *字符串*。 字符串是由 Unicode 码位构成的不可变 [序列](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)。 字符串字面值有多种不同的写法：

- 单引号: `'允许包含有 "双" 引号'`
- 双引号: `"允许包含有 '单' 引号"`。
- 三重引号: `'''三重单引号'''`, `"""三重双引号"""`

使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。

作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，`("spam " "eggs") == "spam eggs"`。

请参阅 [字符串与字节串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#strings) 有解有关不同字符串字面值的更多信息，包括所支持的转义序列，以及使用 `r` (“raw”) 前缀来禁用大多数转义序列的处理。

字符串也可以通过使用 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 构造器从其他对象创建。

由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 *s*, `s[0] == s[0:1]`。

不存在可变的字符串类型，但是 [`str.join()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.join) 或 [`io.StringIO`](https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io.StringIO) 可以被被用来根据多个片段高效率地构建字符串。

在 3.3 版更改: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 `u` 前缀。 它对字符串字面值的含义没有影响，并且不能与 `r` 前缀同时出现。

*class* `str`(*object=’’*)

*class* `str`(*object=b’’*, *encoding=’utf-8’*, *errors=’strict’*)

返回 *object* 的 [字符串](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 版本。 如果未提供 *object* 则返回空字符串。 在其他情况下 `str()` 的行为取决于 *encoding* 或 *errors* 是否有给出，具体见下。

如果 *encoding* 或 *errors* 均未给出，`str(object)` 返回 [`object.__str__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__str__)，这是 *object* 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 *object* 没有 [`__str__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__str__) 方法，则 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 将回退为返回 [`repr(object)`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr)。

如果 *encoding* 或 *errors* 至少给出其中之一，则 *object* 应该是一个 [bytes-like object](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-bytes-like-object) (例如 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 或 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray))。 在此情况下，如果 *object* 是一个 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) (或 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray)) 对象，则 `str(bytes, encoding, errors)` 等价于 [`bytes.decode(encoding, errors)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes.decode)。 否则的话，会在调用 [`bytes.decode()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes.decode) 之前获取缓冲区对象下层的 bytes 对象。 请参阅 [二进制序列类型 —- bytes, bytearray, memoryview](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 与 [缓冲协议](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 了解有关缓冲区对象的信息。

将一个 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象传入 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 而不给出 *encoding* 或 *errors* 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 [`-b`](https://www.bookstack.cn/read/python-3.10.0-zh/ec5d5b3d3a9e7fcc.md#cmdoption-b) 命令行选项）。 例如:

~~~python
>>> str(b'Zoot!')
"b'Zoot!'"
~~~

有关 `str` 类及其方法的更多信息，请参阅下面的 [文本序列类型 —- str](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 和 [字符串的方法](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#string-methods) 小节。 要输出格式化字符串，请参阅 [格式字符串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#f-strings) 和 [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 小节。 此外还可以参阅 [文本处理服务](https://www.bookstack.cn/read/python-3.10.0-zh/1ca18f1369ec8afc.md#stringservices) 小节。

## 字符串的方法

字符串实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的操作，还额外提供了以下列出的一些附加方法。

字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 [`str.format()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.format), [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 和 [自定义字符串格式化](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#string-formatting)) 而另一种是基于 C `printf` 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 ([printf 风格的字符串格式化](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#old-string-formatting))。

标准库的 [文本处理服务](https://www.bookstack.cn/read/python-3.10.0-zh/1ca18f1369ec8afc.md#textservices) 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 [`re`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#module-re) 模块中的正则表达式支持）。

###### `str.capitalize`()

返回原字符串的副本，其首个字符大写，其余为小写。

在 3.8 版更改: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。



###### `str.casefold`()

返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。

消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 `'ß'` 相当于 `"ss"`。 由于它已经是小写了，[`lower()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.lower) 不会对 `'ß'` 做任何改变；而 [`casefold()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.casefold) 则会将其转换为 `"ss"`。

消除大小写算法的描述请参见 Unicode 标准的 3.13 节。



###### `str.center`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其正中。 使用指定的 *fillchar* 填充两边的空位（默认使用 ASCII 空格符）。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.count`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* 会被解读为切片表示法。



###### `str.encode`(*encoding=‘utf-8’*, *errors=’strict’*)

返回原字符串编码为字节串对象的版本。 默认编码为 `'utf-8'`。 可以给出 *errors* 来设置不同的错误处理方案。 *errors* 的默认值为 `'strict'`，表示编码错误会引发 [`UnicodeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#UnicodeError)。 其他可用的值为 `'ignore'`, `'replace'`, `'xmlcharrefreplace'`, `'backslashreplace'` 以及任何其他通过 [`codecs.register_error()`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#codecs.register_error) 注册的值，请参阅 [错误处理方案](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#error-handlers) 小节。 要查看可用的编码列表，请参阅 [标准编码](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#standard-encodings) 小节。



###### `str.endswith`(*suffix*[, *start*[, *end*]])

如果字符串以指定的 *suffix* 结束返回 `True`，否则返回 `False`。 *suffix* 也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。



###### `str.expandtabs`(*tabsize=8*)

返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (`\t`)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (`\n`) 或回车符 (`\r`)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。



###### `str.find`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在 `s[start:end]` 切片内被找到的最小索引。可选参数 *start* 与 *end* 会被解读为切片表示法。如果 *sub* 未被找到则返回 `-1`。

[`find()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.find) 方法应该只在你需要知道 *sub* 所在位置时使用。要检查 *sub* 是否为子字符串，请使用 [`in`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#in) 操作符:

```
>>> 'Py' in 'Python'True
```



###### `str.format(args, kwargs)`

执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 `{}` 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。

~~~python
>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
~~~

请参阅 [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 了解有关可以在格式字符串中指定的各种格式选项的说明。

当使用 `n` 类型 (例如: `'{:n}'.format(1234)`) 来格式化数字 ([`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int), [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float), [`complex`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex), [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal) 及其子类) 的时候，该函数会临时性地将 `LC_CTYPE` 区

域设置为 `LC_NUMERIC` 区域以解码 `localeconv()` 的 `decimal_point` 和 `thousands_sep` 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 

`LC_NUMERIC` 区域会与 `LC_CTYPE` 区域不一致。 这个临时更改会影响其他线程。

在 3.7 版更改: 当使用 `n` 类型格式化数字时，该函数在某些情况下会临时性地将 `LC_CTYPE` 区域设置为 `LC_NUMERIC` 区域。



###### `str.format_map`(*mapping*)

类似于 `str.format(**mapping)`，不同之处在于 `mapping` 会被直接使用而不是复制到一个 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict)。



###### `str.isalnum`()

如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 `True` ， 否则返回 `False` 。是否为字符+数字 (没有符号)。



###### `str.isalpha`()

如果字符串中的所有字符都是字母，并且至少有一个字符，返回 `True` ，否则返回 `False` 。字母字符是指那些在 Unicode 字符数据库中定义为 “Letter” 的字符，即那些具有 “Lm”、”Lt”、”Lu”、”Ll” 或 “Lo” 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的”字母”属性不同。



###### `str.isascii`()

如果字符串为空或字符串中的所有字符都是 ASCII ，返回 `True` ，否则返回 `False` 。ASCII 字符的码点范围是 U+0000-U+007F 。



###### `str.isdecimal`()

如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 `True` ， 否则返回 `False` 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 “Nd” 中的一个字符。



###### `str.isdigit`()

如果字符串中的所有字符都是数字，并且至少有一个字符，返回 `True` ，否则返回 `False` 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。



###### `str.isnumeric`()

如果字符串中至少有一个字符且所有字符均为数值字符则返回 `True` ，否则返回 `False` 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。



###### `str.isidentifier`()

如果字符串是有效的标识符，返回 `True` ，依据语言定义， [标识符和关键字](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#identifiers) 节。

调用 [`keyword.iskeyword()`](https://www.bookstack.cn/read/python-3.10.0-zh/b609c2a0f8769889.md#keyword.iskeyword) 来检测字符串 `s` 是否为保留标识符，例如 [`def`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#def) 和 [`class`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#class)。

~~~python
>>> from keyword import iskeyword
>>> 'hello'.isidentifier(), iskeyword('hello')
True, False
>>> 'def'.isidentifier(), iskeyword('def')
True, True
~~~



###### `str.isprintable`()

如果字符串中所有字符均为可打印字符或字符串为空则返回 `True` ，否则返回 `False` 。 不可打印字符是在 Unicode 字符数据库中被定义为 “Other” 或 “Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 时不必被转义的字符。 它们与字符串写入 [`sys.stdout`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.stdout) 或 [`sys.stderr`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.stderr) 时所需的处理无关。）



###### `str.isspace`()

如果字符串中只有空白字符且至少有一个字符则返回 `True` ，否则返回 `False` 。

*空白* 字符是指在 Unicode 字符数据库 (参见 [`unicodedata`](https://www.bookstack.cn/read/python-3.10.0-zh/526917e1a747e4dd.md#module-unicodedata)) 中主要类别为 `Zs` (“Separator, space”) 或所属双向类为 `WS`, `B` 或 `S` 的字符。



###### `str.istitle`()

如果字符串中至少有一个字符且为标题字符串则返回 `True` ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 `False` 。



###### `str.isupper`()

如果字符串中至少有一个区分大小写的字符 [4](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id15) 且此类字符均为大写则返回 `True` ，否则返回 `False` 。

~~~python
>>> 'BANANA'.isupper()
True
>>> 'banana'.isupper()
False
>>> 'baNana'.isupper()
False
>>> ' '.isupper()
False
~~~



###### `str.join`(*iterable*)

返回一个由 *iterable* 中的字符串拼接而成的字符串。 如果 *iterable* 中存在任何非字符串值包括 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象则会引发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。 调用该方法的字符串将作为元素之间的分隔。



###### `str.ljust`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其中靠左对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.lower`()

返回原字符串的副本，其所有区分大小写的字符均转换为小写。



###### `str.lstrip`([*chars*])

返回原字符串的副本，移除其中的前导字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀；而是会移除参数值的所有组合:

~~~python
>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
~~~

参见 [`str.removeprefix()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.removeprefix) ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:

~~~python
>>> 'Arthur: three!'.lstrip('Arthur: ')
'ee!'
>>> 'Arthur: three!'.removeprefix('Arthur: ')
'three!'
~~~



###### `static str.maketrans (x[, y[, z]])`

此静态方法返回一个可供 [`str.translate()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.translate) 使用的转换对照表。

如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 `None` 的字典。 字符键将会被转换为码位序号。

如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 `None`。



###### `str.partition (sep)`

在 *sep* 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。



###### `str.removeprefix`(*prefix*, */*)

如果字符串以 *前缀* 字符串开头，返回 `string[len(prefix):]` 。否则，返回原始字符串的副本：

~~~python
>>> 'TestHook'.removeprefix('Test')
'Hook'
>>> 'BaseTestCase'.removeprefix('Test')
'BaseTestCase'
~~~



###### `str.removesuffix`(*suffix*, */*)

如果字符串以 *后缀* 字符串结尾，并且 *后缀* 非空，返回 `string[:-len(suffix)]` 。否则，返回原始字符串的副本：

```python
>>> 'MiscTests'.removesuffix('Tests')
'Misc'
>>> 'TmpDirMixin'.removesuffix('Tests')
'TmpDirMixin'
```



###### `str.replace`(*old*, *new*[, *count*])

返回字符串的副本，其中出现的所有子字符串 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。



###### `str.rfind`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在字符串内被找到的最大（最右）索引，这样 *sub* 将包含在 `s[start:end]` 当中。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果未找到则返回 `-1`。



###### `str.rindex`(*sub*[, *start*[, *end*]])

类似于 [`rfind()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.rfind)，但在子字符串 *sub* 未找到时会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。



###### `str.rjust`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其中靠右对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.rpartition`(*sep*)

在 *sep* 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。



###### `str.rsplit`(*sep=None*, *maxsplit=- 1*)

返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 *最右边* 开始。 如果 *sep* 未指定或为 `None`，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，[`rsplit()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.rsplit) 的其他行为都类似于下文所述的 [`split()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.split)。



###### `str.rstrip`([*chars*])

返回原字符串的副本，移除其中的末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个后缀；而是会移除参数值的所有组合:

~~~python
>>> '   spacious   '.rstrip()
'   spacious'
>>> 'mississippi'.rstrip('ipz')
'mississ'
~~~



###### `str.split`(*sep=None*, *maxsplit=- 1*)

返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分（因此，列表最多会有 `maxsplit+1` 个元素）。 如果 *maxsplit* 未指定或为 `-1`，则不限制拆分次数（进行所有可能的拆分）。

如果给出了 *sep*，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 `'1,,2'.split(',')` 将返回 `['1', '', '2']`)。 *sep* 参数可能由多个字符组成 (例如 `'1<>2<>3'.split('<>')` 将返回 `['1', '2', '3']`)。 使用指定的分隔符拆分空字符串将返回 `['']`。



###### `str.splitlines`([*keepends*])

返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 *keepends* 且为真值。

此方法会以下列行边界进行拆分。 特别地，行边界是 [universal newlines](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-universal-newlines) 的一个超集。

| 表示符         | 描述               |
| :------------- | :----------------- |
| `\n`           | 换行               |
| `\r`           | 回车               |
| `\r\n`         | 回车 + 换行        |
| `\v` 或 `\x0b` | 行制表符           |
| `\f` 或 `\x0c` | 换表单             |
| `\x1c`         | 文件分隔符         |
| `\x1d`         | 组分隔符           |
| `\x1e`         | 记录分隔符         |
| `\x85`         | 下一行 (C1 控制码) |
| `\u2028`       | 行分隔符           |
| `\u2029`       | 段分隔符           |

在 3.2 版更改: `\v` 和 `\f` 被添加到行边界列表



###### `str.startswith`(*prefix*[, *start*[, *end*]])

如果字符串以指定的 *prefix* 开始则返回 `True`，否则返回 `False`。 *prefix* 也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。



###### `str.strip`([*chars*])

返回原字符串的副本，移除其中的前导和末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:



###### `str.swapcase`()

返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 `s.swapcase().swapcase() == s` 并不一定为真值。



###### `str.title`()

返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。



###### `str.translate`(*table*)

返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 `__getitem__()` 来实现索引操作的对象，通常为 [mapping](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-mapping) 或 [sequence](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-sequence)。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 `None`，将字符从结果字符串中删除；或引发 [`LookupError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#LookupError) 异常，将字符映射为其自身。

你可以使用 [`str.maketrans()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.maketrans) 基于不同格式的字符到字符映射来创建一个转换映射表。

另请参阅 [`codecs`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#module-codecs) 模块以了解定制字符映射的更灵活方式。



###### `str.upper`()

返回原字符串的副本，其中所有区分大小写的字符 [4](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id15) 均转换为大写。 请注意如果 `s` 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 “Lu” (Letter, uppercase) 而是 “Lt” (Letter, titlecase) 则 `s.upper().isupper()` 有可能为 `False`。

所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。



`str.zfill`(*width*)

返回原字符串的副本，在左边填充 ASCII `'0'` 数码使其长度变为 *width*。 正负值前缀 (`'+'`/`'-'`) 的处理方式是在正负符号 *之后* 填充而非在之前。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。

例如：

~~~python
>>> "42".zfill(5)
'00042'
>>> "-42".zfill(5)
'-0042'
~~~

## `printf` 风格的字符串格式化

注解

此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 [格式化字符串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#f-strings)，[`str.format()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.format) 接口或 [模板字符串](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#template-strings) 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。

字符串具有一种特殊的内置操作：使用 `%` (取模) 运算符。 这也被称为字符串的 *格式化* 或 *插值* 运算符。 对于 `format % values` (其中 *format* 为一个字符串)，在 *format* 中的 `%` 转换标记符将被替换为零个或多个 *values* 条目。 其效果类似于在 C 语言中使用 `sprintf()`。

如果 *format* 要求一个单独参数，则 *values* 可以为一个非元组对象。 [5](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id16) 否则的话，*values* 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。

转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：

1. `'%'` 字符，用于标记转换符的起始。
2. 映射键（可选），由加圆括号的字符序列组成 (例如 `(somename)`)。
3. 转换旗标（可选），用于影响某些转换类型的结果。
4. 最小字段宽度（可选）。 如果指定为 `'*'` (星号)，则实际宽度会从 *values* 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。
5. 精度（可选），以在 `'.'` (点号) 之后加精度值的形式给出。 如果指定为 `'*'` (星号)，则实际精度会从 *values* 元组的下一元素中读取，要转换的对象则为精度之后的元素。
6. 长度修饰符（可选）。
7. 转换类型。

当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 *必须* 包含加圆括号的映射键，对应 `'%'` 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：

~~~python
>>> print('%(language)s has %(number)03d quote types.' %
...       {'language': "Python", "number": 2})
Python has 002 quote types.
~~~

在此情况下格式中不能出现 `*` 标记符（因其需要一个序列类的参数列表）。

转换旗标为：

| 旗标  | 含意                                                         |
| :---- | :----------------------------------------------------------- |
| `‘#’` | 值的转换将使用“替代形式”（具体定义见下文）。                 |
| `‘0’` | 转换将为数字值填充零字符。                                   |
| `‘-‘` | 转换值将靠左对齐（如果同时给出 `‘0’` 转换，则会覆盖后者）。  |
| `‘ ‘` | (空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。  |
| `‘+’` | 符号字符 (`‘+’` 或 `‘-‘`) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。 |

可以给出长度修饰符 (`h`, `l` 或 `L`)，但会被忽略，因为对 Python 来说没有必要 — 所以 `%ld` 等价于 `%d`。

转换类型为：

| 转换符 | 含意                                                         | 备注 |
| :----- | :----------------------------------------------------------- | :--- |
| `‘d’`  | 有符号十进制整数。                                           |      |
| `‘i’`  | 有符号十进制整数。                                           |      |
| `‘o’`  | 有符号八进制数。                                             | (1)  |
| `‘u’`  | 过时类型 — 等价于 `‘d’`。                                    | (6)  |
| `‘x’`  | 有符号十六进制数（小写）。                                   | (2)  |
| `‘X’`  | 有符号十六进制数（大写）。                                   | (2)  |
| `‘e’`  | 浮点指数格式（小写）。                                       | (3)  |
| `‘E’`  | 浮点指数格式（大写）。                                       | (3)  |
| `‘f’`  | 浮点十进制格式。                                             | (3)  |
| `‘F’`  | 浮点十进制格式。                                             | (3)  |
| `‘g’`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。 | (4)  |
| `‘G’`  | 浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。 | (4)  |
| `‘c’`  | 单个字符（接受整数或单个字符的字符串）。                     |      |
| `‘r’`  | 字符串（使用 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 转换任何 Python 对象）。 | (5)  |
| `‘s’`  | 字符串（使用 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 转换任何 Python 对象）。 | (5)  |
| `‘a’`  | 字符串（使用 [`ascii()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ascii) 转换任何 Python 对象）。 | (5)  |
| `‘%’`  | 不转换参数，在结果中输出一个 `‘%’` 字符。                    |      |

注释：

1. 此替代形式会在第一个数码之前插入标示八进制数的前缀 (`'0o'`)。

2. 此替代形式会在第一个数码之前插入 `'0x'` 或 `'0X'` 前缀（取决于是使用 `'x'` 还是 `'X'` 格式）。

3. 此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。

   小数点后的数码位数由精度决定，默认为 6。

4. 此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。

   小数点前后的有效数码位数由精度决定，默认为 6。

5. 如果精度为 `N`，输出将截短为 `N` 个字符。

6. 参见 [**PEP 237**](https://www.python.org/dev/peps/pep-0237)。

由于 Python 字符串显式指明长度，`%s` 转换不会将 `'\0'` 视为字符串的结束。

在 3.1 版更改: 绝对值超过 1e50 的 `%f` 转换不会再被替换为 `%g` 转换。



# 二进制序列类型

操作二进制数据的核心内置类型是 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 和 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray)。 它们由 [`memoryview`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview) 提供支持，该对象使用 [缓冲区协议](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 来访问其他二进制对象所在内存，不需要创建对象的副本。

[`array`](https://www.bookstack.cn/read/python-3.10.0-zh/58981e604b8b221a.md#module-array) 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。

## bytes 对象

bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。

*class* `bytes`([*source*[, *encoding*[, *errors*]]])

首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 `b` 前缀：

- 单引号: `b'同样允许嵌入 "双" 引号'`。
- 双引号: `b"同样允许嵌入 '单' 引号"`。
- 三重引号: `b'''三重单引号'''`, `b"""三重双引号"""`

bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。

像字符串字面值一样，bytes 字面值也可以使用 `r` 前缀来禁用转义序列处理。 请参阅 [字符串与字节串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#strings) 了解有关各种 bytes 字面值形式的详情，包括所支持的转义序列。

虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 `0 <= x < 256` (如果违反此限制将引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError))。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。

除了字面值形式，bytes 对象还可以通过其他几种方式来创建：

- 指定长度的以零值填充的 bytes 对象: `bytes(10)`
- 通过由整数组成的可迭代对象: `bytes(range(20))`
- 通过缓冲区协议复制现有的二进制数据: `bytes(obj)`

另请参阅 [bytes](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytes) 内置类型。

由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：

- *classmethod* `fromhex`(*string*)

  此 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。

~~~python
>>> bytes.fromhex('2Ef0 F1f2  ')
b'.\xf0\xf1\xf2'
~~~

存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。

- `hex`([*sep*[, *bytes_per_sep*]])

  返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。

~~~python
>>> b'\xf0\xf1\xf2'.hex()
'f0f1f2'
~~~

如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 *sep* 形参包含于输出中。 默认会放在每个字节之间。 第二个可选的 *bytes_per_sep* 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。

~~~python
>>> value = b'\xf0\xf1\xf2'
>>> value.hex('-')
'f0-f1-f2'
>>> value.hex('_', 2)
'f0_f1f2'
>>> b'UUDDLRLRAB'.hex(' ', -4)
'55554444 4c524c52 4142'
~~~

由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 *b*，`b[0]` 将为一个整数，而 `b[0:1]` 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。

bytes 对象的表示使用字面值格式 (`b'...'`)，因为它通常都要比像 `bytes([46, 46, 46])` 这样的格式更好用。 你总是可以使用 `list(b)` 将 bytes 对象转换为一个由整数构成的列表。

注解

针对 Python 2.x 用户的说明：在 Python 2.x 系列中，允许 8 位字符串（ 2.x 所提供的最接近内置二进制数据类型的对象）与 Unicode 字符串进行各种隐式转换。 这是为了实现向下兼容的变通做法，以适应 Python 最初只支持 8 位文本而 Unicode 文本是后来才被加入这一事实。 在 Python 3.x 中，这些隐式转换已被取消 —— 8 位二进制数据与 Unicode 文本间的转换必须显式地进行，bytes 与字符串对象的比较结果将总是不相等。



## bytearray 对象

[`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 对象是 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象的可变对应物。

*class* `bytearray`([*source*[, *encoding*[, *errors*]]])

bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：

- 创建一个空实例: `bytearray()`
- 创建一个指定长度的以零值填充的实例: `bytearray(10)`
- 通过由整数组成的可迭代对象: `bytearray(range(20))`
- 通过缓冲区协议复制现有的二进制数据: `bytearray(b'Hi!')`

由于 bytearray 对象是可变的，该对象除了 [bytes 和 bytearray 操作](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes-methods) 中所描述的 bytes 和 bytearray 共有操作之外，还支持 [可变](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-mutable) 序列操作。

另请参见 [bytearray](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytearray) 内置类型。

由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：

- *classmethod* `fromhex`(*string*)

  [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。

  ```
  >>> bytearray.fromhex('2Ef0 F1f2  ')bytearray(b'.\xf0\xf1\xf2')
  ```

  在 3.7 版更改: [`bytearray.fromhex()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray.fromhex) 现在会忽略所有 ASCII 空白符而不只是空格符。

存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。

- `hex`([*sep*[, *bytes_per_sep*]])

  返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。

  ```
  >>> bytearray(b'\xf0\xf1\xf2').hex()'f0f1f2'
  ```

  3.5 新版功能.

  在 3.8 版更改: 与 [`bytes.hex()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes.hex) 相似， [`bytearray.hex()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray.hex) 现在支持可选的 *sep* 和 *bytes_per_sep* 参数以在十六进制输出的字节之间插入分隔符。

由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 *b*，`b[0]` 将为一个整数，而 `b[0:1]` 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。

bytearray 对象的表示使用 bytes 对象字面值格式 (`bytearray(b'...')`)，因为它通常都要比 `bytearray([46, 46, 46])` 这样的格式更好用。 你总是可以使用 `list(b)` 将 bytearray 对象转换为一个由整数构成的列表。

## bytes 和 bytearray 操作

bytes 和 bytearray 对象都支持 [通用](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列操作。 它们不仅能与相同类型的操作数，也能与任何 [bytes-like object](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-bytes-like-object) 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。

与str操作基本一致，详细参照python文档。



# 内存视图

[`memoryview`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview) 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 [缓冲区协议](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 而无需进行拷贝。

*class* `memoryview`(*object*)

创建一个引用 *object* 的 [`memoryview`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview) 。 *object* 必须支持缓冲区协议。支持缓冲区协议的内置对象有 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 和 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 。

[`memoryview`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview) 有 **元素** 的概念， **元素** 指由原始 *object* 处理的原子内存单元。对于许多简单的类型，如 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 和 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) ，一个元素是一个字节，但其他类型，如 [`array.array`](https://www.bookstack.cn/read/python-3.10.0-zh/58981e604b8b221a.md#array.array) 可能有更大的元素。

`len(view)` 与 [`tolist`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview.tolist) 的长度相等。 如果 `view.ndim = 0`，则其长度为 1。 如果 `view.ndim = 1`，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 [`itemsize`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview.itemsize) 属性可向你给出单个元素所占的字节数。

[`memoryview`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview) 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:

~~~python
>>> v = memoryview(b'abcefg')
>>> v[1]
98
>>> v[-1]
103
>>> v[1:4]
<memory at 0x7f3ddc9f4350>
>>> bytes(v[1:4])
b'bce'
~~~

如果 [`format`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#memoryview.format) 是一个来自于 [`struct`](https://www.bookstack.cn/read/python-3.10.0-zh/018c5cf24c5b588d.md#module-struct) 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 *元素*。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 *ndim* 个整数构成的元素进行索引，*ndim* 即其维度。 零维内存视图可以使用空元组进行索引。

这里是一个使用非字节格式的例子:

~~~python
>>> import array
>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])
>>> m = memoryview(a)
>>> m[0]
-11111111
>>> m[-1]
44444444
>>> m[::2].tolist()
[-11111111, -33333333]
~~~

后续查看python文档，我暂时用不到和想不到哪里有用。



# 集合类型 — [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set), [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset)

*set* 对象是由具有唯一性的 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable) 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 （关于其他容器对象请参看 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict), [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 与 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 等内置类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块。）

与其他多项集一样，集合也支持 `x in set`, `len(set)` 和 `for x in set`。 作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。

目前有两种内置集合类型，[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset)。 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 类型是可变的 —- 其内容可以使用 `add()` 和 `remove()` 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 类型是不可变并且为 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable) —- 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。

除了可以使用 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: `{'jack', 'sjoerd'}`。

两个类的构造器具有相同的作用方式：

*class* `set`([*iterable*])

*class* `frozenset`([*iterable*])

返回一个新的 set 或 frozenset 对象，其元素来自于 *iterable*。 集合的元素必须为 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable)。 要表示由集合对象构成的集合，所有的内层集合必须为 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 对象。 如果未指定 *iterable*，则将返回一个新的空集合。

集合可用多种方式来创建:

- 使用花括号内以逗号分隔元素的方式: `{'jack', 'sjoerd'}`
- 使用集合推导式: `{c for c in 'abracadabra' if c not in 'abc'}`
- 使用类型构造器: `set()`, `set('foobar')`, `set(['a', 'b', 'foo'])`

[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 的实例提供以下操作：

- `len(s)`

  返回集合 *s* 中的元素数量（即 *s* 的基数）。

  

- `x in s`

  检测 *x* 是否为 *s* 中的成员。

  

- `x not in s`

  检测 *x* 是否非 *s* 中的成员。

  

- `isdisjoint`(*other*)

  如果集合中没有与 *other* 共有的元素则返回 `True`。 当且仅当两个集合的交集为空集合时，两者为不相交集合。

  

- `issubset`(*other*)

  `set <= other`

  检测是否集合中的每个元素都在 *other* 之中。

  

- `set < other`

  检测集合是否为 *other* 的真子集，即 `set <= other and set != other`。

  

- `issuperset`(*other*)

  `set >= other`

  检测是否 *other* 中的每个元素都在集合之中。

  

- `set > other`

  检测集合是否为 *other* 的真超集，即 `set >= other and set != other`。

  

- `union`(**others*)

  `set | other | ...`

  返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。

  

- `intersection`(**others*)

  `set & other & ...`

  返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。

  

- `difference`(**others*)

  `set - other - ...`

  返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。

  

- `symmetric_difference`(*other*)

  `set ^ other`

  返回一个新集合，其中的元素或属于原集合或属于 *other* 指定的其他集合，但不能同时属于两者。

  

- `copy`()

  返回原集合的浅拷贝。

[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。

[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 的实例与 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 的实例之间基于它们的成员进行比较。 例如 `set('abc') == frozenset('abc')` 返回 `True`，`set('abc') in set([frozenset('abc')])` 也一样。

子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 *所有* 比较均返回 `False`: `a<b`, `a==b`, or `a>b`。

由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 [`list.sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 方法的输出并无定义。

集合的元素，与字典的键类似，必须为 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable)。

混合了 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 实例与 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 的二进制位运算将返回与第一个操作数相同的类型。例如: `frozenset('ab') | set('bc')` 将返回 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 的实例。

下表列出了可用于 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 而不能用于不可变的 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 实例的操作：

- `update`(**others*)

  `set |= other | ...`

  更新集合，添加来自 others 中的所有元素。

  

- `intersection_update`(**others*)

  `set &= other & ...`

  更新集合，只保留其中在所有 others 中也存在的元素。

  

- `difference_update`(**others*)

  `set -= other | ...`

  更新集合，移除其中也存在于 others 中的元素。

  

- `symmetric_difference_update`(*other*)

  `set ^= other`

  更新集合，只保留存在于集合的一方而非共同存在的元素。

  

- `add`(*elem*)

  将元素 *elem* 添加到集合中。

  

- `remove`(*elem*)

  从集合中移除元素 *elem*。 如果 *elem* 不存在于集合中则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

  

- `discard`(*elem*)

  如果元素 *elem* 存在于集合中则将其移除。

  

- `pop`()

  从集合中移除并返回任意一个元素。 如果集合为空则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

  

- `clear`()

  从集合中移除所有元素。

请注意，非运算符版本的 [`update()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.update), [`intersection_update()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.intersection_update), [`difference_update()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.difference_update) 和 [`symmetric_difference_update()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.symmetric_difference_update) 方法将接受任意可迭代对象作为参数。

请注意，`__contains__()`, [`remove()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.remove) 和 [`discard()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset.discard) 方法的 *elem* 参数可能是一个 set。 为支持对一个等价的 frozenset 进行搜索，会根据 *elem* 临时创建一个该类型对象。



# 映射类型 — [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict)

[mapping](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-mapping) 对象会将 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable) 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 *字典*。 （关于其他容器对象请参看 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list), [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 与 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 等内置类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块。）

字典的键 *几乎* 可以是任何值。 非 [hashable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-hashable) 的值，即包含列表、字典或其他可变类型的值（此类对象基于值而非对象标识进行比较）不可用作键。 数字类型用作键时遵循数字比较的一般规则：如果两个数值相等 (例如 `1` 和 `1.0`) 则两者可以被用来索引同一字典条目。 （但是请注意，由于计算机对于浮点数存储的只是近似值，因此将其用作字典键是不明智的。）

字典可以通过将以逗号分隔的 `键: 值` 对列表包含于花括号之内来创建，例如: `{'jack': 4098, 'sjoerd': 4127}` 或 `{4098: 'jack', 4127: 'sjoerd'}`，也可以通过 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 构造器来创建。

*class* `dict`(***kwarg*)

*class* `dict`(*mapping*, ***kwarg*)

*class* `dict`(*iterable*, ***kwarg*)

返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。

字典可用多种方式来创建:

- 使用花括号内以逗号分隔 `键: 值` 对的方式: `{'jack': 4098, 'sjoerd': 4127}` or `{4098: 'jack', 4127: 'sjoerd'}`
- 使用字典推导式: `{}`, `{x: x ** 2 for x in range(10)}`
- 使用类型构造器: `dict()`, `dict([('foo', 100), ('bar', 200)])`, `dict(foo=100, bar=200)`

如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。 否则的话，位置参数必须为一个 [iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterable) 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。

如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。

作为演示，以下示例返回的字典均等于 `{"one": 1, "two": 2, "three": 3}`:

~~~python
>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> f = dict({'one': 1, 'three': 3}, two=2)
>>> a == b == c == d == e == f
True
~~~

像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。

这些是字典所支持的操作（因而自定义的映射类型也应当支持）：

- `list(d)`

  返回字典 *d* 中使用的所有键的列表。

- `len(d)`

  返回字典 *d* 中的项数。

- `d[key]`

  返回 *d* 中以 *key* 为键的项。 如果映射中不存在 *key* 则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

  如果字典的子类定义了方法 `__missing__()` 并且 *key* 不存在，则 `d[key]` 操作将调用该方法并附带键 *key* 作为参数。 `d[key]` 随后将返回或引发 `__missing__(key)` 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 `__missing__()`。 如果未定义 `__missing__()`，则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。 `__missing__()` 必须是一个方法；它不能是一个实例变量:

~~~python
>>> class Counter(dict):
...     def __missing__(self, key):
...         return 0
>>> c = Counter()
>>> c['red']
0
>>> c['red'] += 1
>>> c['red']
1
~~~

- 上面的例子显示了 [`collections.Counter`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#collections.Counter) 实现的部分代码。 还有另一个不同的 `__missing__` 方法是由 [`collections.defaultdict`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#collections.defaultdict) 所使用的。

- `d[key] = value`

  将 `d[key]` 设为 *value*。

- `del d[key]`

  将 `d[key]` 从 *d* 中移除。 如果映射中不存在 *key* 则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

- `key in d`

  如果 *d* 中存在键 *key* 则返回 `True`，否则返回 `False`。

- `key not in d`

  等价于 `not key in d`。

- `iter(d)`

  返回以字典的键为元素的迭代器。 这是 `iter(d.keys())` 的快捷方式。

- `clear`()

  移除字典中的所有元素。

- `copy`()

  返回原字典的浅拷贝。

- *classmethod* `fromkeys`(*iterable*[, *value*])

  使用来自 *iterable* 的键创建一个新字典，并将键值设为 *value*。

  [`fromkeys()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict.fromkeys) 是一个返回新字典的类方法。 *value* 默认为 `None`。 所有值都只引用一个单独的实例，因此让 *value* 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 [字典推导式](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#dict)。

- `get`(*key*[, *default*])

  如果 *key* 存在于字典中则返回 *key* 的值，否则返回 *default*。 如果 *default* 未给出则默认为 `None`，因而此方法绝不会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

- `items`()

  返回由字典项 (`(键, 值)` 对) 组成的一个新视图。 参见 [视图对象文档](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict-views)。

- `keys`()

  返回由字典键组成的一个新视图。 参见 [视图对象文档](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict-views)。

- `pop`(*key*[, *default*])

  如果 *key* 存在于字典中则将其移除并返回其值，否则返回 *default*。 如果 *default* 未给出且 *key* 不存在于字典中，则会引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

- `popitem`()

  从字典中移除并返回一个 `(键, 值)` 对。 键值对会按 LIFO 的顺序被返回。

  [`popitem()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict.popitem) 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 [`popitem()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict.popitem) 将引发 [`KeyError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#KeyError)。

  在 3.7 版更改: 现在会确保采用 LIFO 顺序。 在之前的版本中，[`popitem()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict.popitem) 会返回一个任意的键/值对。

- `reversed(d)`

  返回一个逆序获取字典键的迭代器。 这是 `reversed(d.keys())` 的快捷方式。

  3.8 新版功能.

- `setdefault`(*key*[, *default*])

  如果字典存在键 *key* ，返回它的值。如果不存在，插入值为 *default* 的键 *key* ，并返回 *default* 。 *default* 默认为 `None`。

- `update`([*other*])

  使用来自 *other* 的键/值对更新字典，覆盖原有的键。 返回 `None`。

  [`update()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict.update) 接受另一个字典对象，或者一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键/值对更新字典: `d.update(red=1, blue=2)`。

- `values`()

  返回由字典值组成的一个新视图。 参见 [视图对象文档](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict-views)。

  两个 `dict.values()` 视图之间的相等性比较将总是返回 `False`。 这在 `dict.values()` 与其自身比较时也同样适用:

~~~python
>>> d = {'a': 1}
>>> d.values() == d.values()
False
~~~

- `d | other`

  合并 *d* 和 *other* 中的键和值来创建一个新的字典，两者必须都是字典。当 *d* 和 *other* 有相同键时， *other* 的值优先。

  3.9 新版功能.

- `d |= other`

  用 *other* 的键和值更新字典 *d* ，*other* 可以是 [mapping](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-mapping) 或 [iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterable) 的键值对。当 *d* 和 *other* 有相同键时， *other* 的值优先。

  3.9 新版功能.

两个字典的比较当且仅当它们具有相同的 `(键, 值)` 对时才会相等（不考虑顺序）。 排序比较 (‘<’, ‘<=’, ‘>=’, ‘>’) 会引发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。

字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。

~~~python
>>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
>>> d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
>>> list(d)
['one', 'two', 'three', 'four']
>>> list(d.values())
[1, 2, 3, 4]
>>> d["one"] = 42
>>> d
{'one': 42, 'two': 2, 'three': 3, 'four': 4}
>>> del d["two"]
>>> d["two"] = None
>>> d
{'one': 42, 'three': 3, 'four': 4, 'two': None}
~~~

在 3.7 版更改: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。

字典和字典视图都是可逆的。

~~~python
>>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
>>> d
{'one': 1, 'two': 2, 'three': 3, 'four': 4}
>>> list(reversed(d))
['four', 'three', 'two', 'one']
>>> list(reversed(d.values()))
[4, 3, 2, 1]
>>> list(reversed(d.items()))
[('four', 4), ('three', 3), ('two', 2), ('one', 1)]
~~~

在 3.8 版更改: 字典现在是可逆的。

参见

[`types.MappingProxyType`](https://www.bookstack.cn/read/python-3.10.0-zh/48dcc7e473d42733.md#types.MappingProxyType) 可被用来创建一个 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 的只读视图。