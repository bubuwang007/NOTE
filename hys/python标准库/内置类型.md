以下部分描述了解释器中内置的标准类型。

主要内置类型有数字、序列、映射、类、实例和异常。

有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 `None`。

有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 函数或略有差异的 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 函数）。 后一个函数是在对象由 [`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print) 函数输出时被隐式地调用的。



## 逻辑值检测









## 数字类型 

存在三种不同的数字类型: *整数*, *浮点数* 和 *复数*。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 [`sys.float_info`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.float_info) 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z* 中提取这两个部分，可使用 `z.real` 和 `z.imag`。 （标准库包含附加的数字类型，如表示有理数的 [`fractions.Fraction`](https://www.bookstack.cn/read/python-3.10.0-zh/5133f5b15cc25445.md#fractions.Fraction) 以及以用户定制精度表示浮点数的 [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal)。）

数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 `'j'` 或 `'J'` 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。

Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，”较窄”类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。

构造函数 [`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int)、 [`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) 和 [`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) 可以用来构造特定类型的数字。

所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：[运算符优先级](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#operator-summary)）:

|       运算        |                         结果                         |  备注  |                           完整文档                           |
| :---------------: | :--------------------------------------------------: | :----: | :----------------------------------------------------------: |
|      `x + y`      |                   *x* 和 *y* 的和                    |        |                                                              |
|      `x - y`      |                   *x* 和 *y* 的差                    |        |                                                              |
|      `x *y*`      |                  *x* 和 *y* 的乘积                   |        |                                                              |
|      `x / y`      |                   *x* 和 *y* 的商                    |        |                                                              |
|     `x // y`      |                  *x* 和 *y* 的商数                   |  (1)   |                                                              |
|      `x % y`      |                    `x / y` 的余数                    |  (2)   |                                                              |
|       `-x`        |                       *x* 取反                       |        |                                                              |
|       `+x`        |                       *x* 不变                       |        |                                                              |
|     `abs(x)`      |                  *x* 的绝对值或大小                  |        | [`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs) |
|     `int(x)`      |                  将 *x* 转换为整数                   | (3)(6) | [`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) |
|    `float(x)`     |                 将 *x* 转换为浮点数                  | (4)(6) | [`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) |
| `complex(re, im)` | 一个带有实部 *re* 和虚部 *im* 的复数。*im* 默认为0。 |  (6)   | [`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) |
|  `c.conjugate()`  |                   复数 *c* 的共轭                    |        |                                                              |
|  `divmod(x, y)`   |                  `(x // y, x % y)`                   |  (2)   | [`divmod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#divmod) |
|    `pow(x, y)`    |                   *x* 的 *y* 次幂                    |  (5)   | [`pow()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#pow) |
|      `x * y`      |                   *x* 的 *y* 次幂                    |  (5)   |                                                              |

注释：

1. 也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: `1//2` 为 `0`, `(-1)//2` 为 `-1`, `1//(-2)` 为 `-1` 而 `(-1)//(-2)` 为 `0`。
2. 不可用于复数。 而应在适当条件下使用 [`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs) 转换为浮点数。
3. 从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断；请参阅 [`math.floor()`](https://www.bookstack.cn/read/python-3.10.0-zh/e9747026812ad5ba.md#math.floor) 和 [`math.ceil()`](https://www.bookstack.cn/read/python-3.10.0-zh/e9747026812ad5ba.md#math.ceil) 函数查看转换的完整定义。
4. float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-“ 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。
5. Python 将 `pow(0, 0)` 和 `0 ** 0` 定义为 `1`，这是编程语言的普遍做法。
6. 接受的数字字面值包括数码 `0` 到 `9` 或任何等效的 Unicode 字符（具有 `Nd` 特征属性的代码点）。



### 整数类型的按位运算

按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。

二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 `~` 具有与其他一元算术运算 (`+` and `-`) 相同的优先级。

此表格是以优先级升序排序的按位运算列表:

|   运算   |         结果：         |  备注  |
| :------: | :--------------------: | :----: |
| `x | y`  |  *x* 和 *y* 按位 *或*  |  (4)   |
| `x ^ y`  | *x* 和 *y* 按位 *异或* |  (4)   |
| `x & y`  |  *x* 和 *y* 按位 *与*  |  (4)   |
| `x << n` |    *x* 左移 *n* 位     | (1)(2) |
| `x >> n` |    *x* 右移 *n* 位     | (1)(3) |
|   `~x`   |      *x* 逐位取反      |        |

注释：

1. 负的移位数是非法的，会导致引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。
2. 左移 *n* 位等价于乘以 `pow(2, n)` 。
3. 右移 *n* 位等价于除以 `pow(2, n)` ，作向下取整除法。
4. 使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 `1 + max(x.bit_length(), y.bit_length())` 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。



### 整数类型的附加方法

int 类型实现了 [`numbers.Integral`](https://www.bookstack.cn/read/python-3.10.0-zh/d51eec845f96ba96.md#numbers.Integral) [abstract base class](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class)。 此外，它还提供了其他几个方法:

`int.bit_length`()

返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:

~~~python
>>> n = -37
>>> bin(n)
'-0b100101'
>>> n.bit_length()
6
~~~

等价于:

~~~python
def bit_length(self):
    s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
    s = s.lstrip('-0b') # remove leading zeros and minus sign
    return len(s)       # len('100101') --> 6
~~~

`int.bit_count()`

~~~python
>>> n = 19
>>> bin(n)
'0b10011'
>>> n.bit_count()
3
>>> (-n).bit_count()
3
~~~

等价于:

~~~python
def bit_count(self):
    return bin(self).count("1")
~~~

`int.to_bytes`(*length*, *byteorder*, ***,* signed=False)



### 浮点类型的附加方法

float 类型实现了 [`numbers.Real`](https://www.bookstack.cn/read/python-3.10.0-zh/d51eec845f96ba96.md#numbers.Real) [abstract base class](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class)。 float 还具有以下附加方法。

`float.as_integer_ratio`()

返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError) 而 NaN 则会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

`float.is_integer`()

如果 float 实例可用有限位整数表示则返回 `True`，否则返回 `False`:

~~~python
>>> (-2.0).is_integer()
True
>>> (3.2).is_integer()
False
~~~

两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 *十进制数* 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。

`float.hex`()

以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 `0x` 和尾随的 `p` 加指数。

*classmethod* `float.fromhex`(*s*)

返回以十六进制字符串 *s* 表示的浮点数的类方法。 字符串 *s* 可以带有前导和尾随的空格。

请注意 [`float.hex()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#float.hex) 是实例方法，而 [`float.fromhex()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#float.fromhex) 是类方法。

十六进制字符串采用的形式为:

~~~python
[sign] ['0x'] integer ['.' fraction] ['p' exponent]
~~~



### 数字类型的哈希运算

对于可能为不同类型的数字 `x` 和 `y`，要求 `x == y` 时必定 `hash(x) == hash(y)` (详情参见 `__hash__()` 方法的文档)。

为了便于在各种数字类型 (包括 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int), [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float), [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal) 和 [`fractions.Fraction`](https://www.bookstack.cn/read/python-3.10.0-zh/5133f5b15cc25445.md#fractions.Fraction)) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 和 [`fractions.Fraction`](https://www.bookstack.cn/read/python-3.10.0-zh/5133f5b15cc25445.md#fractions.Fraction) 的全部实例，以及 [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) 和 [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal) 的全部有限实例均可用。 

从本质上说，此函数是通过以一个固定质数 `P` 进行 `P` 降模给出的。 `P` 的值在 Python 中可以 [`sys.hash_info`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.hash_info) 的 `modulus` 属性的形式被访问。

**CPython implementation detail:** 目前所用的质数设定，在 C long 为 32 位的机器上 `P = 2**31 - 1` 而在 C long 为 64 位的机器上 `P = 2**61 - 1`。

详细规则如下所述:

- 如果 `x = m / n` 是一个非负的有理数且 `n` 不可被 `P` 整除，则定义 `hash(x)` 为 `m * invmod(n, P) % P`，其中 `invmod(n, P)` 是对 `n` 模 `P` 取反。

- 如果 `x = m / n` 是一个非负的有理数且 `n` 可被 `P` 整除（但 `m` 不能）则 `n` 不能对 `P` 降模，以上规则不适用；在此情况下则定义 `hash(x)` 为常数值 `sys.hash_info.inf`。

- 如果 `x = m / n` 是一个负的有理数则定义 `hash(x)` 为 `-hash(-x)`。 如果结果哈希值为 `-1` 则将其替换为 `-2`。

- The particular values `sys.hash_info.inf` and `-sys.hash_info.inf` are used as hash values for positive infinity or negative infinity (respectively).
- 对于一个 [`complex`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) 值 `z`，会通过计算 `hash(z.real) + sys.hash_info.imag * hash(z.imag)` 将实部和虚部的哈希值结合起来，并进行降模 `2**sys.hash_info.width` 以使其处于 `range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))` 范围之内。 同样地，如果结果为 `-1` 则将其替换为 `-2`。

~~~python
import sys, math
def hash_fraction(m, n):
    """Compute the hash of a rational number m / n.
    Assumes m and n are integers, with n positive.
    Equivalent to hash(fractions.Fraction(m, n)).
    """
    P = sys.hash_info.modulus
    # Remove common factors of P.  (Unnecessary if m and n already coprime.)
    while m % P == n % P == 0:
        m, n = m // P, n // P
    if n % P == 0:
        hash_value = sys.hash_info.inf
    else:
        # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
        # pow(n, P-2, P) gives the inverse of n modulo P.
        hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
    if m < 0:
        hash_value = -hash_value
    if hash_value == -1:
        hash_value = -2
    return hash_value
def hash_float(x):
    """Compute the hash of a float x."""
    if math.isnan(x):
        return object.__hash__(x)
    elif math.isinf(x):
        return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
    else:
        return hash_fraction(*x.as_integer_ratio())
def hash_complex(z):
    """Compute the hash of a complex number z."""
    hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
    # do a signed reduction modulo 2**sys.hash_info.width
    M = 2**(sys.hash_info.width - 1)
    hash_value = (hash_value & (M - 1)) - (hash_value & M)
    if hash_value == -1:
        hash_value = -2
    return hash_value
~~~



## 迭代器类型

Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。

容器对象要提供迭代支持，必须定义一个方法:

`container.__iter__`()

返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 [`tp_iter`](https://www.bookstack.cn/read/python-3.10.0-zh/b4450a549e143156.md#c.PyTypeObject.tp_iter) 槽位。

迭代器对象自身需要支持以下两个方法，它们共同组成了 *迭代器协议*:

`iterator.__iter__`()

返回迭代器对象本身。 这是同时允许容器和迭代器配合 [`for`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#for) 和 [`in`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#in) 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 [`tp_iter`](https://www.bookstack.cn/read/python-3.10.0-zh/b4450a549e143156.md#c.PyTypeObject.tp_iter) 槽位。

`iterator.__next__`()

从容器中返回下一项。 如果已经没有项可返回，则会引发 [`StopIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopIteration) 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 [`tp_iternext`](https://www.bookstack.cn/read/python-3.10.0-zh/b4450a549e143156.md#c.PyTypeObject.tp_iternext) 槽位。

Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。

一旦迭代器的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法引发了 [`StopIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopIteration)，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。

~~~py
class T_iter:

    count = 0
    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        if self.count > 10:
            raise StopIteration
        return self.count

for i in T_iter():
    print(i)
~~~

## 生成器类型

Python 的 [generator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-generator) 提供了一种实现迭代器协议的便捷方式。 如果容器对象 `__iter__()` 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 `__iter__()` 和 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#generator.__next__) 方法。 有关生成器的更多信息可以参阅 [yield 表达式的文档](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#yieldexpr)。

~~~python
class T_iter2:
    count = 0
    def __iter__(self):
        def gen():
            while True:
                self.count += 1
                if self.count > 10:
                    break
                yield self.count
        return gen()
for i in T_iter2():
    print(i)
~~~



## 序列类型 

有三种基本序列类型：list, tuple 和 range 对象。 为处理 [二进制数据](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 和 [文本字符串](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 而特别定制的附加序列类型会在专门的小节中描述。

### 通用序列操作

大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 [`collections.abc.Sequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.Sequence) ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。

此表按优先级升序列出了序列操作。 在表格中，*s* 和 *t* 是具有相同类型的序列，*n*, *i*, *j* 和 *k* 是整数而 *x* 是任何满足 *s* 所规定的类型和值限制的任意对象。

`in` 和 `not in` 操作具有与比较操作相同的优先级。 `+` (拼接) 和 `*` (重复) 操作具有与对应数值运算相同的优先级。 [3](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id14)

|          运算          |                            结果：                            |  备注  |
| :--------------------: | :----------------------------------------------------------: | :----: |
|        `x in s`        |  如果 *s* 中的某项等于 *x* 则结果为 `True`，否则为 `False`   |  (1)   |
|      `x not in s`      |  如果 *s* 中的某项等于 *x* 则结果为 `False`，否则为 `True`   |  (1)   |
|        `s + t`         |                      *s* 与 *t* 相拼接                       | (6)(7) |
|      `s*n 或 `n*s      |               相当于 *s* 与自身进行 *n* 次拼接               | (2)(7) |
|         `s[i]`         |                  *s* 的第 *i* 项，起始为 0                   |  (3)   |
|        `s[i:j]`        |                   *s* 从 *i* 到 *j* 的切片                   | (3)(4) |
|       `s[i:j:k]`       |             *s* 从 *i* 到 *j* 步长为 *k* 的切片              | (3)(5) |
|        `len(s)`        |                          *s* 的长度                          |        |
|        `min(s)`        |                         *s* 的最小项                         |        |
|        `max(s)`        |                         *s* 的最大项                         |        |
| `s.index(x[, i[, j]])` | *x* 在 *s* 中首次出现项的索引号（索引号在 *i* 或其后且在 *j* 之前） |  (8)   |
|      `s.count(x)`      |                  *x* 在 *s* 中出现的总次数                   |        |

### 不可变序列类型

不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 [`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash) 内置函数的支持。

这种支持允许不可变类型，例如 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 实例被用作 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 键，以及存储在 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 实例中。

尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。

### 可变序列类型

以下表格中的操作是在可变序列类型上定义的。 [`collections.abc.MutableSequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.MutableSequence) ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。

表格中的 *s* 是可变序列类型的实例，*t* 是任意可迭代对象，而 *x* 是符合对 *s* 所规定类型与值限制的任何对象 (例如，[`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 仅接受满足 `0 <= x <= 255` 值限制的整数)。

|           运算            |                            结果：                            | 备注 |
| :-----------------------: | :----------------------------------------------------------: | :--: |
|        `s[i] = x`         |                 将 *s* 的第 *i* 项替换为 *x*                 |      |
|       `s[i:j] = t`        |    将 *s* 从 *i* 到 *j* 的切片替换为可迭代对象 *t* 的内容    |      |
|       `del s[i:j]`        |                     等同于 `s[i:j] = []`                     |      |
|      `s[i:j:k] = t`       |            将 `s[i:j:k]` 的元素替换为 *t* 的元素             | (1)  |
|      `del s[i:j:k]`       |                从列表中移除 `s[i:j:k]` 的元素                |      |
|       `s.append(x)`       |  将 *x* 添加到序列的末尾 (等同于 `s[len(s):len(s)] = [x]`)   |      |
|        `s.clear()`        |           从 *s* 中移除所有项 (等同于 `del s[:]`)            | (5)  |
|        `s.copy()`         |              创建 *s* 的浅拷贝 (等同于 `s[:]`)               | (5)  |
| `s.extend(t)` 或 `s += t` | 用 *t* 的内容扩展 *s* (基本上等同于 `s[len(s):len(s)] = t`)  |      |
|         `s *= n`          |           使用 *s* 的内容重复 *n* 次来对其进行更新           | (6)  |
|     `s.insert(i, x)`      | 在由 *i* 给出的索引位置将 *x* 插入 *s* (等同于 `s[i:i] = [x]`) |      |
|  `s.pop()` or `s.pop(i)`  |          提取在 *i* 位置上的项，并将其从 *s* 中移除          | (2)  |
|       `s.remove(x)`       |          删除 *s* 中第一个 `s[i]` 等于 *x* 的项目。          | (3)  |
|       `s.reverse()`       |                   就地将列表中的元素逆序。                   | (4)  |

注释：

1. *t* 必须与它所替换的切片具有相同的长度。

2. 可选参数 *i* 默认为 `-1`，因此在默认情况下会移除并返回最后一项。

3. 当在 *s* 中找不到 *x* 时 `remove()` 操作会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

4. 当反转大尺寸序列时 `reverse()` 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。

5. 包括 `clear()` 和 `copy()` 是为了与不支持切片操作的可变容器 (例如 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 和 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set)) 的接口保持一致。 `copy()` 不是 [`collections.abc.MutableSequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.MutableSequence) ABC 的一部分，但大多数具体的可变序列类都提供了它。

   3.3 新版功能: `clear()` 和 `copy()` 方法。

6. *n* 值为一个整数，或是一个实现了 [`__index__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__) 的对象。 *n* 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 [通用序列操作](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 中有关 `s * n` 的说明。

#### 列表

列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。

*class* `list`([*iterable*])

可以用多种方式构建列表：

- 使用一对方括号来表示空列表: `[]`
- 使用方括号，其中的项以逗号分隔: `[a]`, `[a, b, c]`
- 使用列表推导式: `[x for x in iterable]`
- 使用类型的构造器: `list()` 或 `list(iterable)`

构造器将构造一个列表，其中的项与 *iterable* 中的项具有相同的的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其它可迭代对象。 如果 *iterable* 已经是一个列表，将创建并返回其副本，类似于 `iterable[:]`。 例如，`list('abc')` 返回 `['a', 'b', 'c']` 而 `list( (1, 2, 3) )` 返回 `[1, 2, 3]`。 如果没有给出参数，构造器将创建一个空列表 `[]`。

其它许多操作也会产生列表，包括 [`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted) 内置函数。

列表实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 和 [可变](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-mutable) 序列的操作。 列表还额外提供了以下方法：

`sort`(***,* key=None*,* reverse=False*)

此方法会对列表进行原地排序，只使用 `<` 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。

[`sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 接受两个仅限以关键字形式传入的参数 ([仅限关键字参数](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#keyword-only-parameter)):

*key* 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 `key=str.lower`)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 `None` 表示直接对列表项排序而不计算一个单独的键值。

可以使用 [`functools.cmp_to_key()`](https://www.bookstack.cn/read/python-3.10.0-zh/428f88eb5e920558.md#functools.cmp_to_key) 将 2.x 风格的 *cmp* 函数转换为 *key* 函数。

*reverse* 为一个布尔值。 如果设为 `True`，则每个列表元素将按反向顺序比较进行排序。

当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 [`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted) 显示地请求一个新的已排序列表实例）。

[`sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再接薪级排序）。

有关排序示例和简要排序教程，请参阅 [排序指南](https://www.bookstack.cn/read/python-3.10.0-zh/099cd199392471a9.md#sortinghowto) 。

**CPython implementation detail:** 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

#### 元组

元组是不可变序列，通常用于储存异构数据的多项集（例如由 [`enumerate()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#enumerate) 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 或 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 的实例）。

*class* `tuple`([*iterable*])

可以用多种方式构建元组：

- 使用一对圆括号来表示空元组: `()`
- 使用一个后缀的逗号来表示单元组: `a,` 或 `(a,)`
- 使用以逗号分隔的多个项: `a, b, c` or `(a, b, c)`
- 使用内置的 [`tuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple): `tuple()` 或 `tuple(iterable)`

构造器将构造一个元组，其中的项与 *iterable* 中的项具有相同的值与顺序。 *iterable* 可以是序列、支持迭代的容器或其他可迭代对象。 如果 *iterable* 已经是一个元组，会不加改变地将其返回。 例如，`tuple('abc')` 返回 `('a', 'b', 'c')` 而 `tuple( [1, 2, 3] )` 返回 `(1, 2, 3)`。 如果没有给出参数，构造器将创建一个空元组 `()`。

请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，`f(a, b, c)` 是在调用函数时附带三个参数，而 `f((a, b, c))` 则是在调用函数时附带一个三元组。

元组实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的操作。

对于通过名称访问相比通过索引访问更清晰的异构数据多项集，[`collections.namedtuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#collections.namedtuple) 可能是比简单元组对象更为合适的选择。

#### range 对象

[`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 类型表示不可变的数字序列，通常用于在 [`for`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#for) 循环中循环指定的次数。

*class* `range`(*stop*)

*class* `range`(*start*, *stop*[, *step*])

range 构造器的参数必须为整数（可以是内置的 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 或任何实现了 `__index__` 特殊方法的对象）。 如果省略 *step* 参数，其默认值为 `1`。 如果省略 *start* 参数，其默认值为 `0`，如果 *step* 为零则会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

如果 *step* 为正值，确定 range `r` 内容的公式为 `r[i] = start + step*i` 其中 `i >= 0` 且 `r[i] < stop`。

如果 *step* 为负值，确定 range 内容的公式仍然为 `r[i] = start + step*i`，但限制条件改为 `i >= 0` 且 `r[i] > stop`.

如果 `r[0]` 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。

元素绝对值大于 [`sys.maxsize`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.maxsize) 的 range 对象是被允许的，但某些特性 (例如 [`len()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#len)) 可能引发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。

一些 range 对象的例子:

~~~python
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(range(0, 30, 5))
[0, 5, 10, 15, 20, 25]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> list(range(0))
[]
>>> list(range(1, 0))
[]
~~~

range 对象实现了 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。

- `start`

  *start* 形参的值 (如果该形参未提供则为 `0`)

- `stop`

  *stop* 形参的值

- `step`

  *step* 形参的值 (如果该形参未提供则为 `1`)

[`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 类型相比常规 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 或 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 的优势在于一个 [`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 `start`, `stop` 和 `step` 值，并会根据需要计算具体单项或子范围的值）。

range 对象实现了 [`collections.abc.Sequence`](https://www.bookstack.cn/read/python-3.10.0-zh/7183cf74f5db7dc0.md#collections.abc.Sequence) ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 (参见 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)):

~~~python
>>> r = range(0, 20, 2)
>>> r
range(0, 20, 2)
>>> 11 in r
False
>>> 10 in r
True
>>> r.index(10)
5
>>> r[5]
10
>>> r[:5]
range(0, 10, 2)
>>> r[-1]
18
~~~

使用 `==` 和 `!=` 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 [`start`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.start), [`stop`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.stop) 和 [`step`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.step) 属性，例如 `range(0) == range(2, 1, 3)` 而 `range(0, 3, 2) == range(0, 4, 2)`。）

在 3.2 版更改: 实现 Sequence ABC。 支持切片和负数索引。 使用 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象在固定时间内进行成员检测，而不是逐一迭代所有项。

在 3.3 版更改: 定义 ‘==’ 和 ‘!=’ 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。

3.3 新版功能: [`start`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.start), [`stop`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.stop) 和 [`step`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range.step) 属性。

参见

- [linspace recipe](http://code.activestate.com/recipes/579000/) 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。

#### 文本序列类型str

在 Python 中处理文本数据是使用 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 对象，也称为 *字符串*。 字符串是由 Unicode 码位构成的不可变 [序列](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)。 字符串字面值有多种不同的写法：

- 单引号: `'允许包含有 "双" 引号'`
- 双引号: `"允许包含有 '单' 引号"`。
- 三重引号: `'''三重单引号'''`, `"""三重双引号"""`

使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。

作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，`("spam " "eggs") == "spam eggs"`。

请参阅 [字符串与字节串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#strings) 有解有关不同字符串字面值的更多信息，包括所支持的转义序列，以及使用 `r` (“raw”) 前缀来禁用大多数转义序列的处理。

字符串也可以通过使用 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 构造器从其他对象创建。

由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 *s*, `s[0] == s[0:1]`。

不存在可变的字符串类型，但是 [`str.join()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.join) 或 [`io.StringIO`](https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io.StringIO) 可以被被用来根据多个片段高效率地构建字符串。

在 3.3 版更改: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 `u` 前缀。 它对字符串字面值的含义没有影响，并且不能与 `r` 前缀同时出现。

*class* `str`(*object=’’*)

*class* `str`(*object=b’’*, *encoding=’utf-8’*, *errors=’strict’*)

返回 *object* 的 [字符串](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 版本。 如果未提供 *object* 则返回空字符串。 在其他情况下 `str()` 的行为取决于 *encoding* 或 *errors* 是否有给出，具体见下。

如果 *encoding* 或 *errors* 均未给出，`str(object)` 返回 [`object.__str__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__str__)，这是 *object* 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 *object* 没有 [`__str__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__str__) 方法，则 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 将回退为返回 [`repr(object)`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr)。

如果 *encoding* 或 *errors* 至少给出其中之一，则 *object* 应该是一个 [bytes-like object](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-bytes-like-object) (例如 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 或 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray))。 在此情况下，如果 *object* 是一个 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) (或 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray)) 对象，则 `str(bytes, encoding, errors)` 等价于 [`bytes.decode(encoding, errors)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes.decode)。 否则的话，会在调用 [`bytes.decode()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes.decode) 之前获取缓冲区对象下层的 bytes 对象。 请参阅 [二进制序列类型 —- bytes, bytearray, memoryview](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 与 [缓冲协议](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 了解有关缓冲区对象的信息。

将一个 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象传入 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 而不给出 *encoding* 或 *errors* 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 [`-b`](https://www.bookstack.cn/read/python-3.10.0-zh/ec5d5b3d3a9e7fcc.md#cmdoption-b) 命令行选项）。 例如:

~~~python
>>> str(b'Zoot!')
"b'Zoot!'"
~~~

有关 `str` 类及其方法的更多信息，请参阅下面的 [文本序列类型 —- str](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq) 和 [字符串的方法](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#string-methods) 小节。 要输出格式化字符串，请参阅 [格式字符串字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#f-strings) 和 [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 小节。 此外还可以参阅 [文本处理服务](https://www.bookstack.cn/read/python-3.10.0-zh/1ca18f1369ec8afc.md#stringservices) 小节。

##### 字符串的方法

字符串实现了所有 [一般](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-common) 序列的操作，还额外提供了以下列出的一些附加方法。

字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 (参阅 [`str.format()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.format), [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 和 [自定义字符串格式化](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#string-formatting)) 而另一种是基于 C `printf` 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 ([printf 风格的字符串格式化](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#old-string-formatting))。

标准库的 [文本处理服务](https://www.bookstack.cn/read/python-3.10.0-zh/1ca18f1369ec8afc.md#textservices) 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 [`re`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#module-re) 模块中的正则表达式支持）。



###### `str.capitalize`()

返回原字符串的副本，其首个字符大写，其余为小写。

在 3.8 版更改: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。



###### `str.casefold`()

返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。

消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 `'ß'` 相当于 `"ss"`。 由于它已经是小写了，[`lower()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.lower) 不会对 `'ß'` 做任何改变；而 [`casefold()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.casefold) 则会将其转换为 `"ss"`。

消除大小写算法的描述请参见 Unicode 标准的 3.13 节。



###### `str.center`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其正中。 使用指定的 *fillchar* 填充两边的空位（默认使用 ASCII 空格符）。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.count`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在 [*start*, *end*] 范围内非重叠出现的次数。 可选参数 *start* 与 *end* 会被解读为切片表示法。



###### `str.encode`(*encoding=‘utf-8’*, *errors=’strict’*)

返回原字符串编码为字节串对象的版本。 默认编码为 `'utf-8'`。 可以给出 *errors* 来设置不同的错误处理方案。 *errors* 的默认值为 `'strict'`，表示编码错误会引发 [`UnicodeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#UnicodeError)。 其他可用的值为 `'ignore'`, `'replace'`, `'xmlcharrefreplace'`, `'backslashreplace'` 以及任何其他通过 [`codecs.register_error()`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#codecs.register_error) 注册的值，请参阅 [错误处理方案](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#error-handlers) 小节。 要查看可用的编码列表，请参阅 [标准编码](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#standard-encodings) 小节。



###### `str.endswith`(*suffix*[, *start*[, *end*]])

如果字符串以指定的 *suffix* 结束返回 `True`，否则返回 `False`。 *suffix* 也可以为由多个供查找的后缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。



###### `str.expandtabs`(*tabsize=8*)

返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 *tabsize* 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (`\t`)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (`\n`) 或回车符 (`\r`)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。



###### `str.find`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在 `s[start:end]` 切片内被找到的最小索引。可选参数 *start* 与 *end* 会被解读为切片表示法。如果 *sub* 未被找到则返回 `-1`。

[`find()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.find) 方法应该只在你需要知道 *sub* 所在位置时使用。要检查 *sub* 是否为子字符串，请使用 [`in`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#in) 操作符:

```
>>> 'Py' in 'Python'True
```



###### `str.format(args, kwargs)`

执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 `{}` 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。

~~~python
>>> "The sum of 1 + 2 is {0}".format(1+2)
'The sum of 1 + 2 is 3'
~~~

请参阅 [格式字符串语法](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatstrings) 了解有关可以在格式字符串中指定的各种格式选项的说明。

当使用 `n` 类型 (例如: `'{:n}'.format(1234)`) 来格式化数字 ([`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int), [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float), [`complex`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex), [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal) 及其子类) 的时候，该函数会临时性地将 `LC_CTYPE` 区

域设置为 `LC_NUMERIC` 区域以解码 `localeconv()` 的 `decimal_point` 和 `thousands_sep` 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 

`LC_NUMERIC` 区域会与 `LC_CTYPE` 区域不一致。 这个临时更改会影响其他线程。

在 3.7 版更改: 当使用 `n` 类型格式化数字时，该函数在某些情况下会临时性地将 `LC_CTYPE` 区域设置为 `LC_NUMERIC` 区域。



###### `str.format_map`(*mapping*)

类似于 `str.format(**mapping)`，不同之处在于 `mapping` 会被直接使用而不是复制到一个 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict)。



###### `str.isalnum`()

如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 `True` ， 否则返回 `False` 。是否为字符+数字 (没有符号)。



###### `str.isalpha`()

如果字符串中的所有字符都是字母，并且至少有一个字符，返回 `True` ，否则返回 `False` 。字母字符是指那些在 Unicode 字符数据库中定义为 “Letter” 的字符，即那些具有 “Lm”、”Lt”、”Lu”、”Ll” 或 “Lo” 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的”字母”属性不同。



###### `str.isascii`()

如果字符串为空或字符串中的所有字符都是 ASCII ，返回 `True` ，否则返回 `False` 。ASCII 字符的码点范围是 U+0000-U+007F 。



###### `str.isdecimal`()

如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 `True` ， 否则返回 `False` 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 “Nd” 中的一个字符。



###### `str.isdigit`()

如果字符串中的所有字符都是数字，并且至少有一个字符，返回 `True` ，否则返回 `False` 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。



###### `str.isnumeric`()

如果字符串中至少有一个字符且所有字符均为数值字符则返回 `True` ，否则返回 `False` 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。



###### `str.isidentifier`()

如果字符串是有效的标识符，返回 `True` ，依据语言定义， [标识符和关键字](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#identifiers) 节。

调用 [`keyword.iskeyword()`](https://www.bookstack.cn/read/python-3.10.0-zh/b609c2a0f8769889.md#keyword.iskeyword) 来检测字符串 `s` 是否为保留标识符，例如 [`def`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#def) 和 [`class`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#class)。

~~~python
>>> from keyword import iskeyword
>>> 'hello'.isidentifier(), iskeyword('hello')
True, False
>>> 'def'.isidentifier(), iskeyword('def')
True, True
~~~



###### `str.isprintable`()

如果字符串中所有字符均为可打印字符或字符串为空则返回 `True` ，否则返回 `False` 。 不可打印字符是在 Unicode 字符数据库中被定义为 “Other” 或 “Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 时不必被转义的字符。 它们与字符串写入 [`sys.stdout`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.stdout) 或 [`sys.stderr`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.stderr) 时所需的处理无关。）



###### `str.isspace`()

如果字符串中只有空白字符且至少有一个字符则返回 `True` ，否则返回 `False` 。

*空白* 字符是指在 Unicode 字符数据库 (参见 [`unicodedata`](https://www.bookstack.cn/read/python-3.10.0-zh/526917e1a747e4dd.md#module-unicodedata)) 中主要类别为 `Zs` (“Separator, space”) 或所属双向类为 `WS`, `B` 或 `S` 的字符。



###### `str.istitle`()

如果字符串中至少有一个字符且为标题字符串则返回 `True` ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 `False` 。



###### `str.isupper`()

如果字符串中至少有一个区分大小写的字符 [4](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id15) 且此类字符均为大写则返回 `True` ，否则返回 `False` 。

~~~python
>>> 'BANANA'.isupper()
True
>>> 'banana'.isupper()
False
>>> 'baNana'.isupper()
False
>>> ' '.isupper()
False
~~~



###### `str.join`(*iterable*)

返回一个由 *iterable* 中的字符串拼接而成的字符串。 如果 *iterable* 中存在任何非字符串值包括 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象则会引发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。 调用该方法的字符串将作为元素之间的分隔。



###### `str.ljust`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其中靠左对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.lower`()

返回原字符串的副本，其所有区分大小写的字符均转换为小写。



###### `str.lstrip`([*chars*])

返回原字符串的副本，移除其中的前导字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀；而是会移除参数值的所有组合:

~~~python
>>> '   spacious   '.lstrip()
'spacious   '
>>> 'www.example.com'.lstrip('cmowz.')
'example.com'
~~~

参见 [`str.removeprefix()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.removeprefix) ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:

~~~python
>>> 'Arthur: three!'.lstrip('Arthur: ')
'ee!'
>>> 'Arthur: three!'.removeprefix('Arthur: ')
'three!'
~~~



###### `static str.maketrans (x[, y[, z]])`

此静态方法返回一个可供 [`str.translate()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.translate) 使用的转换对照表。

如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 `None` 的字典。 字符键将会被转换为码位序号。

如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 `None`。



###### `str.partition (sep)`

在 *sep* 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。



###### `str.removeprefix`(*prefix*, */*)

如果字符串以 *前缀* 字符串开头，返回 `string[len(prefix):]` 。否则，返回原始字符串的副本：

~~~python
>>> 'TestHook'.removeprefix('Test')
'Hook'
>>> 'BaseTestCase'.removeprefix('Test')
'BaseTestCase'
~~~



###### `str.removesuffix`(*suffix*, */*)

如果字符串以 *后缀* 字符串结尾，并且 *后缀* 非空，返回 `string[:-len(suffix)]` 。否则，返回原始字符串的副本：

```python
>>> 'MiscTests'.removesuffix('Tests')
'Misc'
>>> 'TmpDirMixin'.removesuffix('Tests')
'TmpDirMixin'
```



###### `str.replace`(*old*, *new*[, *count*])

返回字符串的副本，其中出现的所有子字符串 *old* 都将被替换为 *new*。 如果给出了可选参数 *count*，则只替换前 *count* 次出现。



###### `str.rfind`(*sub*[, *start*[, *end*]])

返回子字符串 *sub* 在字符串内被找到的最大（最右）索引，这样 *sub* 将包含在 `s[start:end]` 当中。 可选参数 *start* 与 *end* 会被解读为切片表示法。 如果未找到则返回 `-1`。



###### `str.rindex`(*sub*[, *start*[, *end*]])

类似于 [`rfind()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.rfind)，但在子字符串 *sub* 未找到时会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。



###### `str.rjust`(*width*[, *fillchar*])

返回长度为 *width* 的字符串，原字符串在其中靠右对齐。 使用指定的 *fillchar* 填充空位 (默认使用 ASCII 空格符)。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。



###### `str.rpartition`(*sep*)

在 *sep* 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。



###### `str.rsplit`(*sep=None*, *maxsplit=- 1*)

返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分，从 *最右边* 开始。 如果 *sep* 未指定或为 `None`，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，[`rsplit()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.rsplit) 的其他行为都类似于下文所述的 [`split()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.split)。



###### `str.rstrip`([*chars*])

返回原字符串的副本，移除其中的末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个后缀；而是会移除参数值的所有组合:

~~~python
>>> '   spacious   '.rstrip()
'   spacious'
>>> 'mississippi'.rstrip('ipz')
'mississ'
~~~



###### `str.split`(*sep=None*, *maxsplit=- 1*)

返回一个由字符串内单词组成的列表，使用 *sep* 作为分隔字符串。 如果给出了 *maxsplit*，则最多进行 *maxsplit* 次拆分（因此，列表最多会有 `maxsplit+1` 个元素）。 如果 *maxsplit* 未指定或为 `-1`，则不限制拆分次数（进行所有可能的拆分）。

如果给出了 *sep*，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 `'1,,2'.split(',')` 将返回 `['1', '', '2']`)。 *sep* 参数可能由多个字符组成 (例如 `'1<>2<>3'.split('<>')` 将返回 `['1', '2', '3']`)。 使用指定的分隔符拆分空字符串将返回 `['']`。



###### `str.splitlines`([*keepends*])

返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 *keepends* 且为真值。

此方法会以下列行边界进行拆分。 特别地，行边界是 [universal newlines](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-universal-newlines) 的一个超集。

| 表示符         | 描述               |
| :------------- | :----------------- |
| `\n`           | 换行               |
| `\r`           | 回车               |
| `\r\n`         | 回车 + 换行        |
| `\v` 或 `\x0b` | 行制表符           |
| `\f` 或 `\x0c` | 换表单             |
| `\x1c`         | 文件分隔符         |
| `\x1d`         | 组分隔符           |
| `\x1e`         | 记录分隔符         |
| `\x85`         | 下一行 (C1 控制码) |
| `\u2028`       | 行分隔符           |
| `\u2029`       | 段分隔符           |

在 3.2 版更改: `\v` 和 `\f` 被添加到行边界列表



###### `str.startswith`(*prefix*[, *start*[, *end*]])

如果字符串以指定的 *prefix* 开始则返回 `True`，否则返回 `False`。 *prefix* 也可以为由多个供查找的前缀构成的元组。 如果有可选项 *start*，将从所指定位置开始检查。 如果有可选项 *end*，将在所指定位置停止比较。



###### `str.strip`([*chars*])

返回原字符串的副本，移除其中的前导和末尾字符。 *chars* 参数为指定要移除字符的字符串。 如果省略或为 `None`，则 *chars* 参数默认移除空白符。 实际上 *chars* 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:



###### `str.swapcase`()

返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 `s.swapcase().swapcase() == s` 并不一定为真值。



###### `str.title`()

返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。



###### `str.translate`(*table*)

返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 `__getitem__()` 来实现索引操作的对象，通常为 [mapping](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-mapping) 或 [sequence](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-sequence)。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 `None`，将字符从结果字符串中删除；或引发 [`LookupError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#LookupError) 异常，将字符映射为其自身。

你可以使用 [`str.maketrans()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.maketrans) 基于不同格式的字符到字符映射来创建一个转换映射表。

另请参阅 [`codecs`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#module-codecs) 模块以了解定制字符映射的更灵活方式。



###### `str.upper`()

返回原字符串的副本，其中所有区分大小写的字符 [4](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id15) 均转换为大写。 请注意如果 `s` 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 “Lu” (Letter, uppercase) 而是 “Lt” (Letter, titlecase) 则 `s.upper().isupper()` 有可能为 `False`。

所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。



`str.zfill`(*width*)

返回原字符串的副本，在左边填充 ASCII `'0'` 数码使其长度变为 *width*。 正负值前缀 (`'+'`/`'-'`) 的处理方式是在正负符号 *之后* 填充而非在之前。 如果 *width* 小于等于 `len(s)` 则返回原字符串的副本。

例如：

~~~python
>>> "42".zfill(5)
'00042'
>>> "-42".zfill(5)
'-0042'
~~~

