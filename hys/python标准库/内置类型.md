以下部分描述了解释器中内置的标准类型。

主要内置类型有数字、序列、映射、类、实例和异常。

有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 `None`。

有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 函数或略有差异的 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 函数）。 后一个函数是在对象由 [`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print) 函数输出时被隐式地调用的。



## 逻辑值检测

任何对象都可以进行逻辑值的检测，以便在 [`if`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#if) 或 [`while`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#while) 作为条件或是作为下文所述布尔运算的操作数来使用。

一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 `__bool__()` 方法且返回 `False` 或是定义了 `__len__()` 方法且返回零。 [1](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#id12) 下面基本完整地列出了会被视为假值的内置对象:

- 被定义为假值的常量: `None` 和 `False`。
- 任何数值类型的零: `0`, `0.0`, `0j`, `Decimal(0)`, `Fraction(0, 1)`
- 空的序列和多项集: `''`, `()`, `[]`, `{}`, `set()`, `range(0)`

产生布尔值结果的运算和内置函数总是返回 `0` 或 `False` 作为假值，`1` 或 `True` 作为真值，除非另行说明。 （重要例外：布尔运算 `or` 和 `and` 总是返回其中一个操作数。）



## 布尔运算

这些属于布尔运算，按优先级升序排列:

|   运算    |                   结果：                   | 备注 |
| :-------: | :----------------------------------------: | :--: |
| `x or y`  |    if *x* is false, then *y*, else *x*     | (1)  |
| `x and y` |    if *x* is false, then *x*, else *y*     | (2)  |
|  `not x`  | if *x* is false, then `True`, else `False` | (3)  |

注释：

1. 这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。
2. 这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。
3. `not` 的优先级比非布尔运算符低，因此 `not a == b` 会被解读为 `not (a == b)` 而 `a == not b` 会引发语法错误。



## 比较运算

在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，`x < y <= z` 等价于 `x < y and y <= z`，前者的不同之处在于 *y* 只被求值一次（但在两种情况下当 `x < y` 结果为假值时 *z* 都不会被求值）。

此表格汇总了比较运算:

|   运算   |      含意      |
| :------: | :------------: |
|   `<`    |    严格小于    |
|   `<=`   |   小于或等于   |
|   `>`    |    严格大于    |
|   `>=`   |   大于或等于   |
|   `==`   |      等于      |
|   `!=`   |     不等于     |
|   `is`   |    对象标识    |
| `is not` | 否定的对象标识 |

除不同的数字类型外，不同类型的对象不能进行相等比较。`==` 运算符总有定义，但对于某些对象类型（例如，类对象），它等于 [`is`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#is) 。其他 `<`、`<=`、`>` 和 `>=` 运算符仅在有意义的地方定义。例如，当参与比较的参数之一为复数时，它们会抛出 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

具有不同标识的类的实例比较结果通常为不相等，除非类定义了 `__eq__()` 方法。

一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，包括 `__lt__()`, `__le__()`, `__gt__()` 以及 `__ge__()` (而如果你想实现常规意义上的比较操作，通常只要有 `__lt__()` 和 `__eq__()` 就可以了)。

[`is`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#is) 和 [`is not`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#is-not) 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。

还有两种具有相同语法优先级的运算 [`in`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#in) 和 [`not in`](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#not-in)，它们被 [iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterable) 或实现了 `__contains__()` 方法的类型所支持。



## 数字类型 

存在三种不同的数字类型: *整数*, *浮点数* 和 *复数*。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 [`sys.float_info`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.float_info) 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z* 中提取这两个部分，可使用 `z.real` 和 `z.imag`。 （标准库包含附加的数字类型，如表示有理数的 [`fractions.Fraction`](https://www.bookstack.cn/read/python-3.10.0-zh/5133f5b15cc25445.md#fractions.Fraction) 以及以用户定制精度表示浮点数的 [`decimal.Decimal`](https://www.bookstack.cn/read/python-3.10.0-zh/4c889a3207dcceda.md#decimal.Decimal)。）

数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 `'j'` 或 `'J'` 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。

Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，”较窄”类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。

构造函数 [`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int)、 [`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) 和 [`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) 可以用来构造特定类型的数字。

所有数字类型（复数除外）都支持下列运算（有关运算优先级，请参阅：[运算符优先级](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#operator-summary)）:

|       运算        |                         结果                         |  备注  |                           完整文档                           |
| :---------------: | :--------------------------------------------------: | :----: | :----------------------------------------------------------: |
|      `x + y`      |                   *x* 和 *y* 的和                    |        |                                                              |
|      `x - y`      |                   *x* 和 *y* 的差                    |        |                                                              |
|      `x *y*`      |                  *x* 和 *y* 的乘积                   |        |                                                              |
|      `x / y`      |                   *x* 和 *y* 的商                    |        |                                                              |
|     `x // y`      |                  *x* 和 *y* 的商数                   |  (1)   |                                                              |
|      `x % y`      |                    `x / y` 的余数                    |  (2)   |                                                              |
|       `-x`        |                       *x* 取反                       |        |                                                              |
|       `+x`        |                       *x* 不变                       |        |                                                              |
|     `abs(x)`      |                  *x* 的绝对值或大小                  |        | [`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs) |
|     `int(x)`      |                  将 *x* 转换为整数                   | (3)(6) | [`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) |
|    `float(x)`     |                 将 *x* 转换为浮点数                  | (4)(6) | [`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) |
| `complex(re, im)` | 一个带有实部 *re* 和虚部 *im* 的复数。*im* 默认为0。 |  (6)   | [`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) |
|  `c.conjugate()`  |                   复数 *c* 的共轭                    |        |                                                              |
|  `divmod(x, y)`   |                  `(x // y, x % y)`                   |  (2)   | [`divmod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#divmod) |
|    `pow(x, y)`    |                   *x* 的 *y* 次幂                    |  (5)   | [`pow()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#pow) |
|      `x * y`      |                   *x* 的 *y* 次幂                    |  (5)   |                                                              |

注释：

1. 也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: `1//2` 为 `0`, `(-1)//2` 为 `-1`, `1//(-2)` 为 `-1` 而 `(-1)//(-2)` 为 `0`。
2. 不可用于复数。 而应在适当条件下使用 [`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs) 转换为浮点数。
3. 从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断；请参阅 [`math.floor()`](https://www.bookstack.cn/read/python-3.10.0-zh/e9747026812ad5ba.md#math.floor) 和 [`math.ceil()`](https://www.bookstack.cn/read/python-3.10.0-zh/e9747026812ad5ba.md#math.ceil) 函数查看转换的完整定义。
4. float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-“ 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。
5. Python 将 `pow(0, 0)` 和 `0 ** 0` 定义为 `1`，这是编程语言的普遍做法。
6. 接受的数字字面值包括数码 `0` 到 `9` 或任何等效的 Unicode 字符（具有 `Nd` 特征属性的代码点）。



### 整数类型的按位运算

按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。

二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 `~` 具有与其他一元算术运算 (`+` and `-`) 相同的优先级。

此表格是以优先级升序排序的按位运算列表:

|   运算   |         结果：         |  备注  |
| :------: | :--------------------: | :----: |
| `x | y`  |  *x* 和 *y* 按位 *或*  |  (4)   |
| `x ^ y`  | *x* 和 *y* 按位 *异或* |  (4)   |
| `x & y`  |  *x* 和 *y* 按位 *与*  |  (4)   |
| `x << n` |    *x* 左移 *n* 位     | (1)(2) |
| `x >> n` |    *x* 右移 *n* 位     | (1)(3) |
|   `~x`   |      *x* 逐位取反      |        |

注释：

1. 负的移位数是非法的，会导致引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。
2. 左移 *n* 位等价于乘以 `pow(2, n)` 。
3. 右移 *n* 位等价于除以 `pow(2, n)` ，作向下取整除法。
4. 使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 `1 + max(x.bit_length(), y.bit_length())` 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。