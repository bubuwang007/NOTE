# 内置函数

Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。

| 内置函数                                                     |
| :----------------------------------------------------------- |
| **A**[`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs)[`aiter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#aiter)[`all()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#all)[`any()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#any)[`anext()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#anext)[`ascii()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ascii) |
| **B**[`bin()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bin)[`bool()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bool)[`breakpoint()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#breakpoint)[`bytearray()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytearray)[`bytes()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytes) |
| **C**[`callable()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#callable)[`chr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#chr)[`classmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#classmethod)[`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile)[`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) |
| **D**[`delattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#delattr)[`dict()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-dict)[`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir)[`divmod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#divmod) |
| **E**[`enumerate()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#enumerate)[`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval)[`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) |
| **F**[`filter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#filter)[`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float)[`format()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#format)[`frozenset()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-frozenset) |
| **G**[`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr)[`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) |
| **H**[`hasattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hasattr)[`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash)[`help()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#help)[`hex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hex) |
| **I**[`id()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id)[`input()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#input)[`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int)[`isinstance()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#isinstance)[`issubclass()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#issubclass)[`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) |
| **L**[`len()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#len)[`list()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-list)[`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) |
| **M**[`map()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#map)[`max()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#max)[`memoryview()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-memoryview)[`min()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#min) |
| **N**[`next()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#next) |
| **O**[`object()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object)[`oct()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#oct)[`open()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#open)[`ord()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ord) |
| **P**[`pow()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#pow)[`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print)[`property()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#property) |
| **R**[`range()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-range)[`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr)[`reversed()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#reversed)[`round()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#round) |
| **S**[`set()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-set)[`setattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#setattr)[`slice()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#slice)[`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted)[`staticmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#staticmethod)[`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-str)[`sum()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sum)[`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) |
| **T**[`tuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-tuple)[`type()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#type) |
| **V**[`vars()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#vars) |
| **Z**[`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) |
| *[`_import`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#import__)*[`()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#import__) |

# A

`abs`(*x*)

返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 `__abs__()` 的对象。 如果参数是一个复数，则返回它的模。



`aiter`(*async_iterable*)

返回 [asynchronous iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterable) 的 [asynchronous iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterator) 。相当于调用 `x.__aiter__()`。

`aiter(x)` 本身带有 `__aiter__()` 方法，返回 `x`，所以 `aiter(aiter(x))` 与 `aiter(x)` 相同。

注意：与 [`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) 不同，[`aiter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#aiter) 没有两个参数的版本。



`all`(*iterable*)

3.10 新版功能.

如果 *iterable* 的所有元素均为真值（或可迭代对象为空）则返回 `True` 。 等价于：

~~~python
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
~~~



*awaitable* `anext`(*async_iterator*[, *default*])

当进入 await 状态时，从给定 [asynchronous iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterator) 返回下一数据项，迭代完毕则返回 *default*。

这是内置函数 [`next()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#next) 的异步版本，类似于：

调用 *async_iterator* 的 [`__anext__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__anext__) 方法，返回一个 [awaitable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-awaitable)。等待返回迭代器的下一个值。若有给出 *default*，则在迭代完毕后会返回给出的值，否则会触发 [`StopAsyncIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopAsyncIteration)。



`any`(*iterable*)

3.10 新版功能.

如果 *iterable* 的任一元素为真值则返回 `True`。 如果可迭代对象为空，返回 `False`。 等价于:

~~~python
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
~~~



`ascii`(*object*)

与 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 类似，返回一个字符串，表示对象的可打印形式，但在 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 返回的字符串中，非 ASCII 字符会用 `\x`、`\u` 和 `\U` 进行转义。生成的字符串类似于 Python 2 中 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 的返回结果。



# B

`bin`(*x*)

将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 *x* 不是 Python 的 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象，它必须定义 `__index__()` 方法，以便返回整数值。下面是一些例子：

~~~python
>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
~~~



*class* `bool`([*x*])

返回布尔值，`True` 或 `False`。*x* 用标准的 [真值测试过程](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#truth) 进行转换。如果 *x* 为 False 或省略，则返回 `False`；否则返回 `True`。 [`bool`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bool) 类是 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 的子类（见 [数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) ）。它不能再被继承。它唯一的实例就是 `False` 和 `True` （参阅 [布尔值](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bltin-boolean-values) ）。

在 3.7 版更改: *x* 现在只能作为位置参数。



`breakpoint`(**args**, **kws**)

此函数会在调用时将你陷入调试器中。具体来说，它调用 [`sys.breakpointhook()`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.breakpointhook) ，直接传递 `args` 和 `kws` 。默认情况下， `sys.breakpointhook()` 调用 [`pdb.set_trace()`](https://www.bookstack.cn/read/python-3.10.0-zh/ae380ba60ea22c30.md#pdb.set_trace) 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 [`pdb`](https://www.bookstack.cn/read/python-3.10.0-zh/ae380ba60ea22c30.md#module-pdb) 且键入尽可能少的代码即可进入调试器。但是， [`sys.breakpointhook()`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.breakpointhook) 可以设置为其他一些函数并被 [`breakpoint()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#breakpoint) 自动调用，以允许进入你想用的调试器。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `builtins.breakpoint` 并附带参数 `breakpointhook`



*class* `bytearray`([*source*[, *encoding*[, *errors*]]])

3.7 新版功能.

返回一个新的 bytes 数组。 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 类是一个可变序列，包含范围为 0 <= x < 256 的整数。它有可变序列大部分常见的方法，见 [可变序列类型](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-mutable) 的描述；同时有 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 类型的大部分方法，参见 [bytes 和 bytearray 操作](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes-methods)。

可选形参 *source* 可以用不同的方式来初始化数组：

- 如果是一个 *string*，您必须提供 *encoding* 参数（*errors* 参数仍是可选的）；[`bytearray()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 会使用 [`str.encode()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.encode) 方法来将 string 转变成 bytes。
- 如果是一个 *integer*，会初始化大小为该数字的数组，并使用 null 字节填充。
- 如果是一个遵循 [缓冲区接口](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 的对象，该对象的只读缓冲区将被用来初始化字节数组。
- 如果是一个 *iterable* 可迭代对象，它的元素的范围必须是 `0 <= x < 256` 的整数，它会被用作数组的初始内容。

如果没有实参，则创建大小为 0 的数组。

另见 [二进制序列类型 —- bytes, bytearray, memoryview](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 和 [bytearray 对象](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typebytearray)。



# C

`callable`(*object*)

如果参数 *object* 是可调用的就返回 [`True`](https://www.bookstack.cn/read/python-3.10.0-zh/a385553acf159919.md#True)，否则返回 [`False`](https://www.bookstack.cn/read/python-3.10.0-zh/a385553acf159919.md#False)。 如果返回 `True`，调用仍可能失败，但如果返回 `False`，则调用 *object* 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 `__call__()` 则它就是可调用的。



`chr`(*i*)

返回 Unicode 码位为整数 *i* 的字符的字符串格式。例如，`chr(97)` 返回字符串 `'a'`，`chr(8364)` 返回字符串 `'€'`。这是 [`ord()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ord) 的逆函数。

实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 *i* 超过这个范围，会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。



`@classmethod`

把一个方法封装成类方法。

类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：

~~~python
class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
~~~

`@classmethod` 这样的形式称为函数的 [decorator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-decorator) — 详情参阅 [函数定义](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#function)。

类方法的调用可以在类上进行 (例如 `C.f()`) 也可以在实例上进行 (例如 `C().f()`)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。

类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 [`staticmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#staticmethod)。 有关类方法的更多信息，请参阅 [标准类型层级结构](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#types)。

在 3.9 版更改: 类方法现在可以包装其他 [描述器](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-descriptor) 例如 [`property()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#property)。

在 3.10 版更改: 类方法现在继承了方法的属性（`__module__`、`__name__`、`__qualname__`、`__doc__` 和 `__annotations__`），并拥有一个新的``__wrapped__`` 属性。



`compile`(*source*, *filename*, *mode*, *flags=0*, *dont_inherit=False*, *optimize=- 1*)

将 *source* 编译成代码或 AST 对象。代码对象可以被 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 或 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 执行。*source* 可以是常规的字符串、字节字符串，或者 AST 对象。参见 [`ast`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#module-ast) 模块的文档了解如何使用 AST 对象。

*filename* 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 `'<string>'`）。

*mode* 实参指定了编译代码必须用的模式。如果 *source* 是语句序列，可以是 `'exec'`；如果是单一表达式，可以是 `'eval'`；如果是单个交互式语句，可以是 `'single'`。（在最后一种情况下，如果表达式执行结果不是 `None` 将会被打印出来。）

可选参数 *flags* 和 *dont_inherit* 控制应当激活哪个 [编译器选项](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast-compiler-flags) 以及应当允许哪个 [future 特性](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#future)。 如果两者都未提供 (或都为零) 则代码会应用与调用 [`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile) 的代码相同的旗标来编译。 如果给出了 *flags* 参数而未给出 *dont_inherit* (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 *flags* 参数所指定的编译器选项和 future 语句。 如果 *dont_inherit* 为非零整数，则只使用 *flags* 参数 — 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。

编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 [`__future__`](https://www.bookstack.cn/read/python-3.10.0-zh/ef2de9c2babd7a5d.md#module-__future__) 模块的 `_Feature` 实例的 `compiler_flag` 属性中找到。 [编译器旗标](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast-compiler-flags) 可以在 [`ast`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#module-ast) 模块中查找带有 `PyCF_` 前缀的名称。

*optimize* 实参指定编译器的优化级别；默认值 `-1` 选择与解释器的 [`-O`](https://www.bookstack.cn/read/python-3.10.0-zh/ec5d5b3d3a9e7fcc.md#cmdoption-O) 选项相同的优化级别。显式级别为 `0` （没有优化；`__debug__` 为真）、`1` （断言被删除， `__debug__` 为假）或 `2` （文档字符串也被删除）。

如果编译的源码不合法，此函数会触发 [`SyntaxError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#SyntaxError) 异常；如果源码包含 null 字节，则会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。

如果您想分析 Python 代码的 AST 表示，请参阅 [`ast.parse()`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast.parse)。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `compile` 附带参数 `source`, `filename`。

注解

在 `'single'` 或 `'eval'` 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 [`code`](https://www.bookstack.cn/read/python-3.10.0-zh/4d91a488593c979c.md#module-code) 模块更容易检测语句的完整性。

警告

在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。

在 3.2 版更改: Windows 和 Mac 的换行符均可使用。而且在 `'exec'` 模式下的输入不必再以换行符结尾了。另增加了 *optimize* 参数。

在 3.5 版更改: 之前 *source* 中包含 null 字节的话会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

3.8 新版功能: `ast.PyCF_ALLOW_TOP_LEVEL_AWAIT` 现在可在旗标中传入以启用对最高层级 `await`, `async for` 和 `async with` 的支持。



*class* `complex`([*real*[, *imag*]])

返回值为 *real* + *imag**1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了* imag*，则默认值为零，构造函数会像 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 和 [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) 一样进行数值转换。如果两个实参都省略，则返回 `0j`。

对于一个普通 Python 对象 `x`，`complex(x)` 会委托给 `x.__complex__()`。 如果 `__complex__()` 未定义则将回退至 `__float__()`。 如果 `__float__()` 未定义则将回退至 `__index__()`。

注解

当从字符串转换时，字符串在 `+` 或 `-` 的周围必须不能有空格。例如 `complex('1+2j')` 是合法的，但 `complex('1 + 2j')` 会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。

[数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) 描述了复数类型。

在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

在 3.8 版更改: 如果 `__complex__()` 和 `__float__()` 未定义则回退至 `__index__()`。



# D

`delattr`(*object*, *name*)

[`setattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#setattr) 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 `delattr(x, 'foobar')` 等价于 `del x.foobar` 。



*class* `dict`(***kwarg*)

*class* `dict`(*mapping*, ***kwarg*)

*class* `dict`(*iterable*, ***kwarg*)

创建一个新的字典。[`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 对象是一个字典类。参见 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 和 [映射类型 —- dict](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesmapping) 了解这个类。

其他容器类型，请参见内置的 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list)、[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块。



`dir`([*object*])

如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。

如果对象有一个名为 `__dir__()` 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 `__getattr__()` 或 `__getattribute__()` 函数的对象能够自定义 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 来报告它们的属性。

如果对象未提供 `__dir__()` 方法，该函数会尽量从对象的 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 `__getattr__()` 方法时，结果可能不准确。

默认的 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：

- 如果对象是模块对象，则列表包含模块的属性名称。
- 如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。
- 否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。

返回的列表按字母表排序。例如：

```
>>> import struct>>> dir()   # show the names in the module namespace  ['__builtins__', '__name__', 'struct']>>> dir(struct)   # show the names in the struct module ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__initializing__', '__loader__', '__name__', '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into', 'unpack', 'unpack_from']>>> class Shape:...     def __dir__(self):...         return ['area', 'perimeter', 'location']>>> s = Shape()>>> dir(s)['area', 'location', 'perimeter']
```

注解

因为 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。



`divmod`(*a*, *b*)

以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 `(a // b, a % b)` 相同。对于浮点数则结果为``(q, a % b)``，其中 *q* 通常为 `math.floor(a / b)`，但可能比它小 1。在任何情况下，`q * b + a % b` 都非常接近 *a*，如果 `a % b` 非零，则结果符号与 *b* 相同，并且 `0 <= abs(a % b) < abs(b)`。



# E

`enumerate`(*iterable*, *start=0*)

返回一个枚举对象。*iterable* 必须是一个序列，或 [iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterator)，或其他支持迭代的对象。 [`enumerate()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#enumerate) 返回的迭代器的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法返回一个元组，里面包含一个计数值（从 *start* 开始，默认为 0）和通过迭代 *iterable* 获得的值。

```
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

等价于:

```python
def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1
```



`eval`(*expression*[, *globals*[, *locals*]])

实参是一个字符串，以及可选的 globals 和 locals。*globals* 实参必须是一个字典。*locals* 可以是任何映射对象。

表达式解析参数 *expression* 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 *globals* 和 *locals* 字典作为全局和局部命名空间。 如果存在 *globals* 字典，并且不包含 `__builtins__` 键的值，则在解析 *expression* 之前会插入以该字符串为键以对内置模块 [`builtins`](https://www.bookstack.cn/read/python-3.10.0-zh/081707c85e5c8af0.md#module-builtins) 的字典的引用为值的项。 这样就可以在将 *globals* 传给 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 之前通过向其传入你自己的 `__builtins__` 字典来控制可供被执行代码可以使用哪些内置模块。 如果 *locals* 字典被省略则它默认为 *globals* 字典。 如果两个字典都被省略，则将使用调用 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 的环境中的 *globals* 和 *locals* 来执行该表达式。 注意，*eval()* 无法访问闭包环境中的 [嵌套作用域](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-nested-scope) (非局部变量)。

返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：

```
>>> x = 1
>>> eval('x+1')
2
```

该函数还可用于执行任意代码对象（比如由 [`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile) 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为 *mode* 的 `'exec'` 进行了编译，那么 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 的返回值将为 `None`。

提示： [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数支持语句的动态执行。 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 和 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数分别返回当前的全局和本地字典，可供传给 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 或 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 使用。

如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。

另外可以参阅 [`ast.literal_eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast.literal_eval)，该函数可以安全执行仅包含文字的表达式字符串。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `exec` 附带参数 `code_object`



`exec`(*object*[, *globals*[, *locals*]])

这个函数支持动态执行 Python 代码。 *object* 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 [1](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id2) 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的“文件输入”一节）。 请注意即使在传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数的代码的上下文中，[`nonlocal`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#nonlocal), [`yield`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#yield) 和 [`return`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#return) 语句也不能在函数定义以外使用。 该函数的返回值是 `None`。

无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 *globals*，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 *globals* 和 *locals*，则将分别用于全局变量和局部变量。*locals* 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 *globals* 和 *locals*，代码执行起来就像嵌入到某个类定义中一样。

如果 *globals* 字典不包含 `__builtins__` 键值，则将为该键插入对内建 [`builtins`](https://www.bookstack.cn/read/python-3.10.0-zh/081707c85e5c8af0.md#module-builtins) 模块字典的引用。因此，在将执行的代码传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 之前，可以通过将自己的 `__builtins__` 字典插入到 *globals* 中来控制可以使用哪些内置代码。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `exec` 附带参数 `code_object`。

注解

内置 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 和 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数各自返回当前的全局和本地字典，因此可以将它们传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 的第二个和第三个实参。

注解

默认情况下，*locals* 的行为如下面 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数描述的一样：不要试图改变默认的 *locals* 字典。如果您想在 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数返回时知道代码对 *locals* 的变动，请明确地传递 *locals* 字典。



# F

`filter`(*function*, *iterable*)

用 *iterable* 中函数 *function* 返回真的那些元素，构建一个新的迭代器。*iterable* 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 *function* 是 `None` ，则会假设它是一个身份函数，即 *iterable* 中所有返回假的元素会被移除。

请注意， `filter(function, iterable)` 相当于一个生成器表达式，当 function 不是 `None` 的时候为 `(item for item in iterable if function(item))`；function 是 `None` 的时候为 `(item for item in iterable if item)` 。

请参阅 [`itertools.filterfalse()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.filterfalse) 了解，只有 *function* 返回 false 时才选取 *iterable* 中元素的补充函数。



*class* `float`([*x*])

返回从数字或字符串 *x* 生成的浮点数。

如果参数是个字符串，则应包含一个十进制数字，前面可选带上符号，也可选前后带有空白符。符号可以是``‘+’`` 或 `'-'`；`'+'` 符号对值没有影响。参数也可以是一个代表 NaN（非数字）或正负无穷大的字符串。更确切地说，在去除前导和尾部的空白符后，输入参数必须符合以下语法：

~~~python
sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
~~~

这里的 `floatnumber` 是指 Python 的浮点数格式，在 [浮点数字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#floating) 中有介绍。大小写没有关系，所以“inf”、“Inf”、“INFINITY”、“iNfINity”都可接受为正无穷的拼写形式。

另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。

对于一个普通 Python 对象 `x`，`float(x)` 会委托给 `x.__float__()`。 如果 `__float__()` 未定义则将回退至 `__index__()`。

如果没有实参，则返回 `0.0` 。



`format`(*value*[, *format_spec*])

将 *value* 转换为“格式化后”的形式，格式由 *format_spec* 进行控制。*format_spec* 的解释方式取决于 *value* 参数的类型；但大多数内置类型使用一种标准的格式化语法： [格式规格迷你语言](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatspec)。

默认的 *format_spec* 是一个空字符串，它通常给出与调用 [`str(value)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 相同的结果。

调用 `format(value, format_spec)` 会转换成 `type(value).__format__(value, format_spec)` ，所以实例字典中的 `__format__()` 方法将不会调用。如果方法搜索回退到 [`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object) 类但 *format_spec* 不为空，或者如果 *format_spec* 或返回值不是字符串，则会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

在 3.4 版更改: 当 *format_spec* 不是空字符串时， `object().__format__(format_spec)` 会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。



*class* `frozenset`([*iterable*])

返回一个新的 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 对象，它包含可选参数 *iterable* 中的元素。 `frozenset` 是一个内置的类。有关此类的文档，请参阅 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 和 [集合类型 —- set, frozenset](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-set)。

请参阅内建的 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set)、[`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list)、[`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 和 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块来了解其它的容器。



# G

`getattr`(*object*, *name*[, *default*])

返回对象命名属性的值。*name* 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， `getattr(x, 'foobar')` 等同于 `x.foobar`。如果指定的属性不存在，且提供了 *default* 值，则返回它，否则触发 [`AttributeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#AttributeError)。

注解

由于 [私有名称混合](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#private-name-mangling) 发生在编译时，因此必须 手动混合私有属性（以两个下划线打头的属性）名称以使使用 [`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr) 来提取它。



`globals`()

返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。



# H

`hasattr`(*object*, *name*)

该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 `True`，否则返回 `False`。（此功能是通过调用 `getattr(object, name)` 看是否有 [`AttributeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#AttributeError) 异常来实现的。）



`hash`(*object*)

返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。

注解

如果对象实现了自己的 `__hash__()` 方法，请注意，[`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash) 根据机器的字长来截断返回值。另请参阅 `__hash__()`。



`help`([*object*])

启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。

请注意，如果在调用 [`help()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#help) 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。详情请参阅 [有关仅限位置形参的 FAQ 条目](https://www.bookstack.cn/read/python-3.10.0-zh/0c13e3b82cdf8d41.md#faq-positional-only-arguments)。

该函数通过 [`site`](https://www.bookstack.cn/read/python-3.10.0-zh/45534d8b6c7003d0.md#module-site) 模块加入到内置命名空间。

在 3.4 版更改: [`pydoc`](https://www.bookstack.cn/read/python-3.10.0-zh/cce4aac0b84df460.md#module-pydoc) 和 [`inspect`](https://www.bookstack.cn/read/python-3.10.0-zh/996a92025b483010.md#module-inspect) 的变更使得可调用对象的签名信息更加全面和一致。



`hex`(*x*)

将整数转换为以“0x”为前缀的小写十六进制字符串。如果 *x* 不是 Python [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象，则必须定义返回整数的 `__index__()` 方法。一些例子：

~~~python
>>> hex(255)
'0xff'
>>> hex(-42)
'-0x2a'
~~~



# I

`id`(*object*)

返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 [`id()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id) 值。



`input`([*prompt*])

如果存在 *prompt* 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 [`EOFError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#EOFError)。例如:

~~~python
>>> s = input('--> ')  
--> Monty Python's Flying Circus
>>> s  
"Monty Python's Flying Circus"
~~~

如果加载了 [`readline`](https://www.bookstack.cn/read/python-3.10.0-zh/4702d003cd17da61.md#module-readline) 模块，[`input()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#input) 将使用它来提供复杂的行编辑和历史记录功能。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `builtins.input` 附带参数 `prompt`。

在成功读取输入之后引发一个审计事件 `builtins.input/result` 附带结果。



*class* `int`([*x*])

*class* `int`(*x*, *base=10*)

返回一个基于数字或字符串 *x* 构造的整数对象，或者在未给出参数时返回 `0`。 如果 *x* 定义了 `__int__()`，`int(x)` 将返回 `x.__int__()`。 如果 *x* 定义了 `__index__()`，它将返回 `x.__index__()`。 如果 *x* 定义了 `__trunc__()`，它将返回 `x.__trunc__()`。 对于浮点数，它将向零舍入。

如果 *x* 不是数字，或者有 *base* 参数，*x* 必须是字符串、[`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes)、表示进制为 *base* 的 [整数字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#integers) 的 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 实例。该文字前可以有 `+` 或 `-` （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 `a` 到 `z` （或 `A` 到 `Z` ）表示 10 到 35。默认的 *base* 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 `0b`/`0B` 、 `0o`/`0O` 、 `0x`/`0X` 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 `int('010', 0)` 是非法的，但 `int('010')` 和 `int('010', 8)` 是合法的。

整数类型定义请参阅 [数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) 。

在 3.4 版更改: 如果 *base* 不是 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 的实例，但 *base* 对象有 [`base.__index__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__) 方法，则会调用该方法来获取进制数。以前的版本使用 [`base.__int__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__int__) 而不是 [`base.__index__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__)。

在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

在 3.7 版更改: *x* 现在只能作为位置参数。

在 3.8 版更改: 如果 `__int__()` 未定义则回退至 `__index__()`。



`isinstance`(*object*, *classinfo*)

如果 *object* 参数是 *classinfo* 参数的实例，或其（直接、间接或 [virtual](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class) ）子类的实例，则返回 `True`。 如果 *object* 不是给定类型的对象，则总是返回 `False`。如果 *classinfo* 是类型对象的元组（或由该类元组递归生成）或多个类型的 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)，那么当 *object* 是其中任一类型的实例时就会返回 `True`。如果 *classinfo* 不是某个类型或类型元组，将会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

在 3.10 版更改: *classinfo* 可以是一个 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)。



`issubclass`(*class*, *classinfo*)

Return `True` if *class* is a subclass (direct, indirect, or [virtual](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class)) of *classinfo*. A class is considered a subclass of itself. *classinfo* may be a tuple of class objects or a [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union), in which case return `True` if *class* is a subclass of any entry in *classinfo*. In any other case, a [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) exception is raised.

在 3.10 版更改: *classinfo* 可以是一个 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)。



`iter`(*object*[, *sentinel*])

返回一个 [iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterator) 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，*object* 必须是支持迭代协议（有 `__iter__()` 方法）的集合对象，或必须支持序列协议（有 `__getitem__()` 方法，且数字参数从 `0` 开始）。如果它不支持这些协议，会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。如果有第二个实参 *sentinel*，那么 *object* 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法时都会不带实参地调用 *object*；如果返回的结果是 *sentinel* 则触发 [`StopIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopIteration)，否则返回调用结果。

另请参阅 [迭代器类型](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typeiter)。

适合 [`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:



# L

`len`(*s*)

返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。

**CPython implementation detail:** `len` 对于大于 [`sys.maxsize`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.maxsize) 的长度如 [`range(2 ** 100)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 会引发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。



*class* `list`([*iterable*])

虽然被称为函数，[`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 实际上是一种可变序列类型，详情请参阅 [列表](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-list) 和 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)。



`locals`()

更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 时将返回自由变量。 请注意在模块层级上，[`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 和 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 是同一个字典。



# M

`map`(*function*, *iterable*, *…*)

返回一个将 *function* 应用于 *iterable* 中每一项并输出其结果的迭代器。 如果传入了额外的 *iterable* 参数，*function* 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况，请参阅 [`itertools.starmap()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.starmap)。



*class* `memoryview`(*object*)

返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 [内存视图](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typememoryview)。



`min`(*iterable*, ***[,* key*,* default*])

`min`(*arg1*, *arg2*, **args*[, *key*])

返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。

如果只提供了一个位置参数，它必须是 [iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterable)，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。

有两个可选只能用关键字的实参。*key* 实参指定排序函数用的参数，如传给 [`list.sort()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list.sort) 的。*default* 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 *default* ，则会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError)。

如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 `sorted(iterable, key=keyfunc)[0]` 和 `heapq.nsmallest(1, iterable, key=keyfunc)` 保持一致。



# N

`next`(*iterator*[, *default*])

通过调用 *iterator* 的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法获取下一个元素。如果迭代器耗尽，则返回给定的 *default*，如果没有默认值则触发 [`StopIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopIteration)。



# O

*class* `object`

返回一个不带特征的新对象。[`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object) 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。

注解

由于 [`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object) 没有 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__)，因此无法将任意属性赋给 [`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object) 的实例。



`oct`(*x*)

将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 *x* 不是 Python 的 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象，那它需要定义 `__index__()` 方法返回一个整数。一些例子：



`open`(*file*, *mode=’r’*, *buffering=- 1*, *encoding=None*, *errors=None*, *newline=None*, *closefd=True*, *opener=None*)

打开 *file* 并返回对应的 [file object](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-file-object)。 如果该文件不能被打开，则引发 [`OSError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OSError)。 请参阅 [读写文件](https://www.bookstack.cn/read/python-3.10.0-zh/2f482edad70ee50c.md#tut-files) 获取此函数的更多用法示例。

*file* 是一个 [path-like object](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-path-like-object)，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I/O 对象关闭时它也会关闭，除非将 *closefd* 设为 `False` 。）

*mode* 是可选的字符串，用于指定打开文件的模式。默认值是 `'r'` ，表示以文本模式打开并读取文件。其他常见模式有：写入模式 `'w'` （已存在文件会被清空）、独占创建模式 `'x'` 、追加写入模式 `'a'` （在 *某些* Unix 系统中，无论当前文件指针在什么位置，*所有* 的写入操作都会追加到文件末尾）。在文本模式，如果未指定 *encoding* ，则会根据当前平台决定编码格式：调用 `locale.getpreferredencoding(False)` 获取当前地区的编码。若要读写原生字节格式，请使用二进制模式且不要指定 *encoding*。可用的模式有：

| 字符  |                    含意                    |
| :---: | :----------------------------------------: |
| `‘r’` |                读取（默认）                |
| `‘w’` |             写入，并先截断文件             |
| `‘x’` |      排它性创建，如果文件已存在则失败      |
| `‘a’` | 打开文件用于写入，如果文件存在则在末尾追加 |
| `‘b’` |                 二进制模式                 |
| `‘t’` |              文本模式（默认）              |
| `‘+’` |         打开用于更新（读取与写入）         |

默认模式为 `'r'` （打开文件用于读取文本，与 `'rt'` 同义）。`'w+'` 和 `'w+b'` 模式将打开文件并清空内容。而 `'r+'` 和 `'r+b'` 模式将打开文件但不清空内容。

正如在 [概述](https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io-overview) 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 *mode* 参数中的 `'b'` ）返回的内容为 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 对象，不进行任何解码。在文本模式下（默认情况下，或者在 *mode* 参数中包含 `'t'` ）时，文件内容返回为 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) ，首先使用指定的 *encoding* （如果给定）或者使用平台默认的的字节编码解码。

注解

Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。

*buffering* 是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且>1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出 *buffering* 参数，则默认缓冲策略的工作方式如下:

- 二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 [`io.DEFAULT_BUFFER_SIZE`](https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io.DEFAULT_BUFFER_SIZE)。在许多系统上，缓冲区的长度通常为4096或8192字节。
- “交互式”文本文件（ [`isatty()`](https://www.bookstack.cn/read/python-3.10.0-zh/30550efc10d3e98c.md#io.IOBase.isatty) 返回 `True` 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。

*encoding* 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 [`locale.getpreferredencoding()`](https://www.bookstack.cn/read/python-3.10.0-zh/4a2d90a543713035.md#locale.getpreferredencoding) 返回何值），但可以使用任何Python支持的 [text encoding](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-text-encoding) 。有关支持的编码列表，请参阅 [`codecs`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#module-codecs) 模块。

*errors* 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序（列在 [错误处理方案](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#error-handlers) ），但是使用 [`codecs.register_error()`](https://www.bookstack.cn/read/python-3.10.0-zh/293ee43d4addffee.md#codecs.register_error) 注册的任何错误处理名称也是有效的。标准名称包括:

- 如果存在编码错误，`'strict'` 会引发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。 默认值 `None` 具有相同的效果。
- `'ignore'` 忽略错误。请注意，忽略编码错误可能会导致数据丢失。
- `'replace'` 会将替换标记（例如 `'?'` ）插入有错误数据的地方。
- `'surrogateescape'` 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 `surrogateescape` 错误处理句柄时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。
- 只有在写入文件时才支持 `'xmlcharrefreplace'`。编码不支持的字符将替换为相应的XML字符引用 `&#nnn;`。
- `'backslashreplace'` 用Python的反向转义序列替换格式错误的数据。
- `'namereplace'` （也只在编写时支持）用 `\N{...}` 转义序列替换不支持的字符。

*newline* 控制 [universal newlines](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-universal-newlines) 模式如何生效（它仅适用于文本模式）。它可以是 `None`，`''`，`'\n'`，`'\r'` 和 `'\r\n'`。它的工作原理:

- 从流中读取输入时，如果 *newline* 为 `None`，则启用通用换行模式。输入中的行可以以 `'\n'`，`'\r'` 或 `'\r\n'` 结尾，这些行被翻译成 `'\n'` 在返回呼叫者之前。如果它是 `''`，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。
- 将输出写入流时，如果 *newline* 为 `None`，则写入的任何 `'\n'` 字符都将转换为系统默认行分隔符 [`os.linesep`](https://www.bookstack.cn/read/python-3.10.0-zh/e0ddb7e321e3f9bf.md#os.linesep)。如果 *newline* 是 `''` 或 `'\n'`，则不进行翻译。如果 *newline* 是任何其他合法值，则写入的任何 `'\n'` 字符将被转换为给定的字符串。

如果 *closefd* 为 `False` 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 *closefd* 必须为 `True` （默认值），否则将触发错误。

可以通过传递可调用的 *opener* 来使用自定义开启器。然后通过使用参数（ *file*，*flags* ）调用 *opener* 获得文件对象的基础文件描述符。 *opener* 必须返回一个打开的文件描述符（使用 [`os.open`](https://www.bookstack.cn/read/python-3.10.0-zh/e0ddb7e321e3f9bf.md#os.open) as *opener* 时与传递 `None` 的效果相同）。

新创建的文件是 [不可继承的](https://www.bookstack.cn/read/python-3.10.0-zh/e0ddb7e321e3f9bf.md#fd-inheritance)。



`ord`(*c*)

对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 `ord('a')` 返回整数 `97`， `ord('€')` （欧元符号）返回 `8364` 。这是 [`chr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#chr) 的逆函数。



# P

`pow`(*base*, *exp*[, *mod*])

返回 *base* 的 *exp* 次幂；如果 *mod* 存在，则返回 *base* 的 *exp* 次幂对 *mod* 取余（比 `pow(base, exp) % mod` 更高效）。 两参数形式 `pow(base, exp)` 等价于乘方运算符: `base**exp`。



`print`(**objects*, *sep=’ ‘*, *end=’\n’*, *file=sys.stdout*, *flush=False*)

将 *objects* 打印输出至 *file* 指定的文本流，以 *sep* 分隔并在末尾加上 *end*。 *sep* 、 *end* 、 *file* 和 *flush* 必须以关键字参数的形式给出。

所有非关键字参数都会被转换为字符串，就像是执行了 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 一样，并会被写入到流，以 *sep* 且在末尾加上 *end*。 *sep* 和 *end* 都必须为字符串；它们也可以为 `None`，这意味着使用默认值。 如果没有给出 *objects*，则 [`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print) 将只写入 *end*。

*file* 参数必须是一个具有 `write(string)` 方法的对象；如果参数不存在或为 `None`，则将使用 [`sys.stdout`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.stdout)。 由于要打印的参数会被转换为文本字符串，因此 [`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print) 不能用于二进制模式的文件对象。 对于这些对象，应改用 `file.write(...)`。

输出是否缓存通常取决于 *file*，但如果 *flush* 关键字参数为 True，输出流会被强制刷新。

在 3.3 版更改: 增加了 *flush* 关键字参数。



*class* `property`(*fget=None*, *fset=None*, *fdel=None*, *doc=None*)

返回 property 属性。

*fget* 是获取属性值的函数。 *fset* 是用于设置属性值的函数。 *fdel* 是用于删除属性值的函数。并且 *doc* 为属性对象创建文档字符串。

一个典型的用法是定义一个托管属性 `x`:

~~~python
class C:
    def __init__(self):
        self._x = None
    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx, "I'm the 'x' property.")
~~~

如果 *c* 为 *C* 的实例，`c.x` 将调用 getter，`c.x = value` 将调用 setter， `del c.x` 将调用 deleter。

如果给出，*doc* 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 *fget* 的文档字符串（如果存在）。 这令使用 [`property()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#property) 作为 [decorator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-decorator) 来创建只读的特征属性可以很容易地实现:

~~~python
class Parrot:
    def __init__(self):
        self._voltage = 100000
    @property
    def voltage(self):
        """Get the current voltage."""
        return self._voltage
~~~

以上 `@property` 装饰器会将 `voltage()` 方法转化为一个具有相同名称的只读属性的 “getter”，并将 *voltage* 的文档字符串设置为 “Get the current voltage.”

特征属性对象具有 `getter`, `setter` 以及 `deleter` 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来解释:

~~~python
class C:
    def __init__(self):
        self._x = None
    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
~~~

上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 `x`。)

返回的特征属性对象同样具有与构造器参数相对应的属性 `fget`, `fset` 和 `fdel`。

在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。



# R

*class* `range`(*stop*)

*class* `range`(*start*, *stop*[, *step*])

虽然被称为函数，但 [`range`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 实际上是一个不可变的序列类型，参见在 [range 对象](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-range) 与 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq) 中的文档说明。



`repr`(*object*)

返回对象的可打印形式字符串。对于很多类型而言，本函数试图返回的字符串，会与将对象传给 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 所生成的结果相同；不然，结果就是一个尖括号包裹的字符串，包含了对象类型名称及其附加信息，附加信息通常包括对象的名称和内存地址。通过定义 `__repr__()` 方法，类可以控制本函数将为实例返回的内容。



`reversed`(*seq*)

返回一个反向的 [iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterator)。 *seq* 必须是一个具有 `__reversed__()` 方法的对象或者是支持该序列协议（具有从 `0` 开始的整数类型参数的 `__len__()` 方法和 `__getitem__()` 方法）。



`round`(*number*[, *ndigits*])

返回 *number* 舍入到小数点后 *ndigits* 位精度的值。 如果 *ndigits* 被省略或为 `None`，则返回最接近输入值的整数。

对于支持 [`round()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#round) 方法的内置类型，结果值会舍入至最接近的 10 的负 *ndigits* 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，`round(0.5)` 和 `round(-0.5)` 均得出 `0` 而 `round(1.5)` 则为 `2`。*ndigits* 可为任意整数值（正数、零或负数）。如果省略了 *ndigits* 或为 `None` ，则返回值将为整数。否则返回值与 *number* 的类型相同。

对于一般的 Python 对象 `number`, `round` 将委托给 `number.__round__`。

注解

对浮点数执行 [`round()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#round) 的行为可能会令人惊讶：例如，`round(2.675, 2)` 将给出 `2.67` 而不是期望的 `2.68`。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 请参阅 [浮点算术：争议和限制](https://www.bookstack.cn/read/python-3.10.0-zh/09e87a44df2afdc2.md#tut-fp-issues) 了解更多信息。



# S

*class* `set`([*iterable*])

返回一个新的 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 对象，可以选择带有从 *iterable* 获取的元素。 `set` 是一个内置类型。 请查看 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [集合类型 —- set, frozenset](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-set) 获取关于这个类的文档。

有关其他容器请参看内置的 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset), [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list), [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 和 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块。



`setattr`(*object*, *name*, *value*)

本函数与 [`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr) 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 `setattr(x, 'foobar', 123)` 等价于 `x.foobar = 123`。

注解

由于 [私有名称混合](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#private-name-mangling) 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 [`setattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#setattr) 来设置它。



*class* `slice`(*stop*)

*class* `slice`(*start*, *stop*[, *step*])

返回一个 [slice](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-slice) 对象，代表由 `range(start, stop, step)` 指定索引集的切片。 其中参数 *start* 和 *step* 的默认值为 `None`。切片对象具有只读数据属性 `start` 、`stop` 和 `step`，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： `a[start:stop:step]` 或 `a[start:stop, i]`。 另一种方案是返回迭代器对象，可参阅 [`itertools.islice()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.islice) 。



`sorted`(*iterable*, ***,* key=None*,* reverse=False*)

根据 *iterable* 中的项返回一个新的已排序列表。

具有两个可选参数，它们都必须指定为关键字参数。

*key* 指定带有单个参数的函数，用于从 *iterable* 的每个元素中提取用于比较的键 (例如 `key=str.lower`)。 默认值为 `None` (直接比较元素)。

*reverse* 为一个布尔值。 如果设为 `True`，则每个列表元素将按反向顺序比较进行排序。

使用 [`functools.cmp_to_key()`](https://www.bookstack.cn/read/python-3.10.0-zh/428f88eb5e920558.md#functools.cmp_to_key) 可将老式的 *cmp* 函数转换为 *key* 函数。

内置的 [`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted) 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再按薪级排序）。



`@staticmethod`

将方法转换为静态方法。



*class* `str`(*object=’’*)

*class* `str`(*object=b’’*, *encoding=’utf-8’*, *errors=’strict’*)

返回一个 [`str`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 版本的 *object* 。有关详细信息，请参阅 [`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 。

`str` 是内置字符串 [class](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-class) 。更多关于字符串的信息查看 [文本序列类型 —- str](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#textseq)。

`sum`(*iterable*, */*, *start=0*)

从 *start* 开始自左向右对 *iterable* 的项求和并返回总计值。 *iterable* 的项通常为数字，而 start 值则不允许为字符串。

对某些用例来说，存在 [`sum()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sum) 的更好替代。 拼接字符串序列的更好更快方式是调用 `''.join(sequence)`。 要以扩展精度对浮点值求和，请参阅 [`math.fsum()`](https://www.bookstack.cn/read/python-3.10.0-zh/e9747026812ad5ba.md#math.fsum)。 要拼接一系列可迭代对象，请考虑使用 [`itertools.chain()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.chain)。



*class* `super`([*type*[, *object-or-type*]])

返回一个代理对象，它会将方法调用委托给 *type* 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。

*object-or-type* 确定用于搜索的 [method resolution order](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-method-resolution-order)。 搜索会从 *type* 之后的类开始。

举例来说，如果 *object-or-type* 的 [`__mro__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#class.__mro__) 为 `D -> B -> C -> A -> object` 并且 *type* 的值为 `B`，则 [`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 将会搜索 `C -> A -> object`。

*object-or-type* 的 [`__mro__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#class.__mro__) 属性列出了 [`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr) 和 [`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 所共同使用的方法解析搜索顺序。 该属性是动态的，可以在任何继承层级结构发生更新的时候被改变。

如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 `isinstance(obj, type)` 必须为真值。 如果第二个参数为一个类型，则 `issubclass(type2, type)` 必须为真值（这适用于类方法）。

*super* 有两个典型用例。 在具有单继承的类层级结构中，*super* 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 *super* 的用法非常相似。

第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。

对于以上两个用例，典型的超类调用看起来是这样的:

~~~python
class C(B):
    def method(self, arg):
        super().method(arg)    # This does the same thing as:
                               # super(C, self).method(arg)
~~~

除了方法查找之外，[`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 [描述器](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-descriptor)。

请注意 [`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 `super().__getitem__(name)`。 它做到这一点是通过实现自己的 `__getattribute__()` 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，[`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 在像 `super()[name]` 这样使用语句或操作符进行隐式查找时则未被定义。

还要注意的是，除了零个参数的形式以外，[`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。

对于有关如何使用 [`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) 来如何设计协作类的实用建议，请参阅 [使用 super() 的指南](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)。



# T

*class* `tuple`([*iterable*])

虽然被称为函数，但 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 实际上是一个不可变的序列类型，参见在 [元组](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-tuple) 与 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq) 中的文档说明。



*class* `type`(*object*)

*class* `type`(*name*, *bases*, *dict*, ***kwds*)

传入一个参数时，返回 *object* 的类型。 返回值是一个 type 对象，通常与 [`object.__class__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#instance.__class__) 所返回的对象相同。

推荐使用 [`isinstance()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#isinstance) 内置函数来检测对象的类型，因为它会考虑子类的情况。

传入三个参数时，返回一个新的 type 对象。 这在本质上是 [`class`](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#class) 语句的一种动态形式，*name* 字符串即类名并会成为 [`__name__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#definition.__name__) 属性；*bases* 元组包含基类并会成为 [`__bases__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#class.__bases__) 属性；如果为空则会添加所有类的终极基类 [`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object)。 *dict* 字典包含类主体的属性和方法定义；它在成为 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 [`type`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#type) 对象:

~~~python
>>> class X:
...     a = 1
...
>>> X = type('X', (), dict(a=1))
~~~

提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 [`__init_subclass__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__init_subclass__))，相当于类定义中关键字 (除了 *metaclass*) 的行为方式。

另请参阅 [自定义类创建](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#class-customization)。

在 3.6 版更改: [`type`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#type) 的子类如果未重载 `type.__new__`，将不再能使用一个参数的形式来获取对象的类型。



# V

`vars`([*object*])

返回模块、类、实例或任何其它具有 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性的对象的 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性。

模块和实例这样的对象具有可更新的 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性；但是，其它对象的 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性可能会设为限制写入（例如，类会使用 [`types.MappingProxyType`](https://www.bookstack.cn/read/python-3.10.0-zh/48dcc7e473d42733.md#types.MappingProxyType) 来防止直接更新字典）。

不带参数时，[`vars()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#vars) 的行为类似 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals)。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。

如果指定了一个对象但它没有 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性（例如，当它所属的类定义了 [`__slots__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__slots__) 属性时）则会引发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。



# Z

`zip`(**iterables*, *strict=False*)

在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。

示例:

~~~PYTHON
>>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):
...     print(item)
...
(1, 'sugar')
(2, 'spice')
(3, 'everything nice')
~~~

更正式的说法： [`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 返回元组的迭代器，其中第 *i* 个元组包含的是每个参数迭代器的第 *i* 个元素。

不妨换一种方式认识 [`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) ：它会把行变成列，把列变成行。这类似于 [矩阵转置](https://en.wikipedia.org/wiki/Transpose) 。

[`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 是延迟执行的：直至迭代时才会对元素进行处理，比如 `for` 循环或放入 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 中。

值得考虑的是，传给 [`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：

- 默认情况下，[`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：

~~~python
>>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
[(0, 'fee'), (1, 'fi'), (2, 'fo')]
~~~

- 通常 [`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 用于可迭代对象等长的情况下。这时建议用 `strict=True` 的选项。输出与普通的 [`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 相同：。

~~~python
>>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
[('a', 1), ('b', 2), ('c', 3)]
~~~

- 为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 [`itertools.zip_longest()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.zip_longest) 来完成。

极端例子是只有一个可迭代对象参数，[`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。



`__import__`(*name*, *globals=None*, *locals=None*, *fromlist=()*, *level=0*)

注解

与 [`importlib.import_module()`](https://www.bookstack.cn/read/python-3.10.0-zh/4b07ba26f05a70fb.md#importlib.import_module) 不同，这是一个日常 Python 编程中不需要用到的高级函数。