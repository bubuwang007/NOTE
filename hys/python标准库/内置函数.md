# 内置函数

Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。

| 内置函数                                                     |
| :----------------------------------------------------------- |
| **A**[`abs()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#abs)[`aiter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#aiter)[`all()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#all)[`any()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#any)[`anext()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#anext)[`ascii()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ascii) |
| **B**[`bin()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bin)[`bool()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bool)[`breakpoint()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#breakpoint)[`bytearray()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytearray)[`bytes()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-bytes) |
| **C**[`callable()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#callable)[`chr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#chr)[`classmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#classmethod)[`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile)[`complex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#complex) |
| **D**[`delattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#delattr)[`dict()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-dict)[`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir)[`divmod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#divmod) |
| **E**[`enumerate()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#enumerate)[`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval)[`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) |
| **F**[`filter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#filter)[`float()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float)[`format()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#format)[`frozenset()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-frozenset) |
| **G**[`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr)[`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) |
| **H**[`hasattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hasattr)[`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash)[`help()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#help)[`hex()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hex) |
| **I**[`id()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id)[`input()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#input)[`int()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int)[`isinstance()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#isinstance)[`issubclass()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#issubclass)[`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) |
| **L**[`len()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#len)[`list()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-list)[`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) |
| **M**[`map()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#map)[`max()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#max)[`memoryview()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-memoryview)[`min()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#min) |
| **N**[`next()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#next) |
| **O**[`object()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object)[`oct()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#oct)[`open()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#open)[`ord()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ord) |
| **P**[`pow()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#pow)[`print()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#print)[`property()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#property) |
| **R**[`range()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-range)[`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr)[`reversed()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#reversed)[`round()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#round) |
| **S**[`set()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-set)[`setattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#setattr)[`slice()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#slice)[`sorted()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sorted)[`staticmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#staticmethod)[`str()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-str)[`sum()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#sum)[`super()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#super) |
| **T**[`tuple()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#func-tuple)[`type()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#type) |
| **V**[`vars()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#vars) |
| **Z**[`zip()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#zip) |
| *[`_import`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#import__)*[`()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#import__) |

# A

`abs`(*x*)

返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 `__abs__()` 的对象。 如果参数是一个复数，则返回它的模。



`aiter`(*async_iterable*)

返回 [asynchronous iterable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterable) 的 [asynchronous iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterator) 。相当于调用 `x.__aiter__()`。

`aiter(x)` 本身带有 `__aiter__()` 方法，返回 `x`，所以 `aiter(aiter(x))` 与 `aiter(x)` 相同。

注意：与 [`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) 不同，[`aiter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#aiter) 没有两个参数的版本。



`all`(*iterable*)

3.10 新版功能.

如果 *iterable* 的所有元素均为真值（或可迭代对象为空）则返回 `True` 。 等价于：

~~~python
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
~~~



*awaitable* `anext`(*async_iterator*[, *default*])

当进入 await 状态时，从给定 [asynchronous iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-asynchronous-iterator) 返回下一数据项，迭代完毕则返回 *default*。

这是内置函数 [`next()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#next) 的异步版本，类似于：

调用 *async_iterator* 的 [`__anext__()`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__anext__) 方法，返回一个 [awaitable](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-awaitable)。等待返回迭代器的下一个值。若有给出 *default*，则在迭代完毕后会返回给出的值，否则会触发 [`StopAsyncIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopAsyncIteration)。



`any`(*iterable*)

3.10 新版功能.

如果 *iterable* 的任一元素为真值则返回 `True`。 如果可迭代对象为空，返回 `False`。 等价于:

~~~python
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
~~~



`ascii`(*object*)

与 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 类似，返回一个字符串，表示对象的可打印形式，但在 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 返回的字符串中，非 ASCII 字符会用 `\x`、`\u` 和 `\U` 进行转义。生成的字符串类似于 Python 2 中 [`repr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#repr) 的返回结果。



# B

`bin`(*x*)

将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 *x* 不是 Python 的 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象，它必须定义 `__index__()` 方法，以便返回整数值。下面是一些例子：

~~~python
>>> bin(3)
'0b11'
>>> bin(-10)
'-0b1010'
~~~



*class* `bool`([*x*])

返回布尔值，`True` 或 `False`。*x* 用标准的 [真值测试过程](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#truth) 进行转换。如果 *x* 为 False 或省略，则返回 `False`；否则返回 `True`。 [`bool`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#bool) 类是 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 的子类（见 [数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) ）。它不能再被继承。它唯一的实例就是 `False` 和 `True` （参阅 [布尔值](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bltin-boolean-values) ）。

在 3.7 版更改: *x* 现在只能作为位置参数。



`breakpoint`(**args**, **kws**)

此函数会在调用时将你陷入调试器中。具体来说，它调用 [`sys.breakpointhook()`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.breakpointhook) ，直接传递 `args` 和 `kws` 。默认情况下， `sys.breakpointhook()` 调用 [`pdb.set_trace()`](https://www.bookstack.cn/read/python-3.10.0-zh/ae380ba60ea22c30.md#pdb.set_trace) 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 [`pdb`](https://www.bookstack.cn/read/python-3.10.0-zh/ae380ba60ea22c30.md#module-pdb) 且键入尽可能少的代码即可进入调试器。但是， [`sys.breakpointhook()`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.breakpointhook) 可以设置为其他一些函数并被 [`breakpoint()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#breakpoint) 自动调用，以允许进入你想用的调试器。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `builtins.breakpoint` 并附带参数 `breakpointhook`



*class* `bytearray`([*source*[, *encoding*[, *errors*]]])

3.7 新版功能.

返回一个新的 bytes 数组。 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 类是一个可变序列，包含范围为 0 <= x < 256 的整数。它有可变序列大部分常见的方法，见 [可变序列类型](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-mutable) 的描述；同时有 [`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes) 类型的大部分方法，参见 [bytes 和 bytearray 操作](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes-methods)。

可选形参 *source* 可以用不同的方式来初始化数组：

- 如果是一个 *string*，您必须提供 *encoding* 参数（*errors* 参数仍是可选的）；[`bytearray()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 会使用 [`str.encode()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str.encode) 方法来将 string 转变成 bytes。
- 如果是一个 *integer*，会初始化大小为该数字的数组，并使用 null 字节填充。
- 如果是一个遵循 [缓冲区接口](https://www.bookstack.cn/read/python-3.10.0-zh/bb3925174f309147.md#bufferobjects) 的对象，该对象的只读缓冲区将被用来初始化字节数组。
- 如果是一个 *iterable* 可迭代对象，它的元素的范围必须是 `0 <= x < 256` 的整数，它会被用作数组的初始内容。

如果没有实参，则创建大小为 0 的数组。

另见 [二进制序列类型 —- bytes, bytearray, memoryview](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#binaryseq) 和 [bytearray 对象](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typebytearray)。



# C

`callable`(*object*)

如果参数 *object* 是可调用的就返回 [`True`](https://www.bookstack.cn/read/python-3.10.0-zh/a385553acf159919.md#True)，否则返回 [`False`](https://www.bookstack.cn/read/python-3.10.0-zh/a385553acf159919.md#False)。 如果返回 `True`，调用仍可能失败，但如果返回 `False`，则调用 *object* 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 `__call__()` 则它就是可调用的。



`chr`(*i*)

返回 Unicode 码位为整数 *i* 的字符的字符串格式。例如，`chr(97)` 返回字符串 `'a'`，`chr(8364)` 返回字符串 `'€'`。这是 [`ord()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#ord) 的逆函数。

实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 *i* 超过这个范围，会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。



`@classmethod`

把一个方法封装成类方法。

类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：

~~~python
class C:
    @classmethod
    def f(cls, arg1, arg2, ...): ...
~~~

`@classmethod` 这样的形式称为函数的 [decorator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-decorator) — 详情参阅 [函数定义](https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#function)。

类方法的调用可以在类上进行 (例如 `C.f()`) 也可以在实例上进行 (例如 `C().f()`)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。

类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 [`staticmethod()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#staticmethod)。 有关类方法的更多信息，请参阅 [标准类型层级结构](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#types)。

在 3.9 版更改: 类方法现在可以包装其他 [描述器](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-descriptor) 例如 [`property()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#property)。

在 3.10 版更改: 类方法现在继承了方法的属性（`__module__`、`__name__`、`__qualname__`、`__doc__` 和 `__annotations__`），并拥有一个新的``__wrapped__`` 属性。



`compile`(*source*, *filename*, *mode*, *flags=0*, *dont_inherit=False*, *optimize=- 1*)

将 *source* 编译成代码或 AST 对象。代码对象可以被 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 或 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 执行。*source* 可以是常规的字符串、字节字符串，或者 AST 对象。参见 [`ast`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#module-ast) 模块的文档了解如何使用 AST 对象。

*filename* 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 `'<string>'`）。

*mode* 实参指定了编译代码必须用的模式。如果 *source* 是语句序列，可以是 `'exec'`；如果是单一表达式，可以是 `'eval'`；如果是单个交互式语句，可以是 `'single'`。（在最后一种情况下，如果表达式执行结果不是 `None` 将会被打印出来。）

可选参数 *flags* 和 *dont_inherit* 控制应当激活哪个 [编译器选项](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast-compiler-flags) 以及应当允许哪个 [future 特性](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#future)。 如果两者都未提供 (或都为零) 则代码会应用与调用 [`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile) 的代码相同的旗标来编译。 如果给出了 *flags* 参数而未给出 *dont_inherit* (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 *flags* 参数所指定的编译器选项和 future 语句。 如果 *dont_inherit* 为非零整数，则只使用 *flags* 参数 — 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。

编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 [`__future__`](https://www.bookstack.cn/read/python-3.10.0-zh/ef2de9c2babd7a5d.md#module-__future__) 模块的 `_Feature` 实例的 `compiler_flag` 属性中找到。 [编译器旗标](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast-compiler-flags) 可以在 [`ast`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#module-ast) 模块中查找带有 `PyCF_` 前缀的名称。

*optimize* 实参指定编译器的优化级别；默认值 `-1` 选择与解释器的 [`-O`](https://www.bookstack.cn/read/python-3.10.0-zh/ec5d5b3d3a9e7fcc.md#cmdoption-O) 选项相同的优化级别。显式级别为 `0` （没有优化；`__debug__` 为真）、`1` （断言被删除， `__debug__` 为假）或 `2` （文档字符串也被删除）。

如果编译的源码不合法，此函数会触发 [`SyntaxError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#SyntaxError) 异常；如果源码包含 null 字节，则会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。

如果您想分析 Python 代码的 AST 表示，请参阅 [`ast.parse()`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast.parse)。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `compile` 附带参数 `source`, `filename`。

注解

在 `'single'` 或 `'eval'` 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 [`code`](https://www.bookstack.cn/read/python-3.10.0-zh/4d91a488593c979c.md#module-code) 模块更容易检测语句的完整性。

警告

在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。

在 3.2 版更改: Windows 和 Mac 的换行符均可使用。而且在 `'exec'` 模式下的输入不必再以换行符结尾了。另增加了 *optimize* 参数。

在 3.5 版更改: 之前 *source* 中包含 null 字节的话会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

3.8 新版功能: `ast.PyCF_ALLOW_TOP_LEVEL_AWAIT` 现在可在旗标中传入以启用对最高层级 `await`, `async for` 和 `async with` 的支持。



*class* `complex`([*real*[, *imag*]])

返回值为 *real* + *imag**1j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了* imag*，则默认值为零，构造函数会像 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 和 [`float`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#float) 一样进行数值转换。如果两个实参都省略，则返回 `0j`。

对于一个普通 Python 对象 `x`，`complex(x)` 会委托给 `x.__complex__()`。 如果 `__complex__()` 未定义则将回退至 `__float__()`。 如果 `__float__()` 未定义则将回退至 `__index__()`。

注解

当从字符串转换时，字符串在 `+` 或 `-` 的周围必须不能有空格。例如 `complex('1+2j')` 是合法的，但 `complex('1 + 2j')` 会触发 [`ValueError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#ValueError) 异常。

[数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) 描述了复数类型。

在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

在 3.8 版更改: 如果 `__complex__()` 和 `__float__()` 未定义则回退至 `__index__()`。



# D

`delattr`(*object*, *name*)

[`setattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#setattr) 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 `delattr(x, 'foobar')` 等价于 `del x.foobar` 。



*class* `dict`(***kwarg*)

*class* `dict`(*mapping*, ***kwarg*)

*class* `dict`(*iterable*, ***kwarg*)

创建一个新的字典。[`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 对象是一个字典类。参见 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 和 [映射类型 —- dict](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesmapping) 了解这个类。

其他容器类型，请参见内置的 [`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list)、[`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set) 和 [`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块。



`dir`([*object*])

如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。

如果对象有一个名为 `__dir__()` 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 `__getattr__()` 或 `__getattribute__()` 函数的对象能够自定义 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 来报告它们的属性。

如果对象未提供 `__dir__()` 方法，该函数会尽量从对象的 [`__dict__`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#object.__dict__) 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 `__getattr__()` 方法时，结果可能不准确。

默认的 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：

- 如果对象是模块对象，则列表包含模块的属性名称。
- 如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。
- 否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。

返回的列表按字母表排序。例如：

```
>>> import struct>>> dir()   # show the names in the module namespace  ['__builtins__', '__name__', 'struct']>>> dir(struct)   # show the names in the struct module ['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__initializing__', '__loader__', '__name__', '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into', 'unpack', 'unpack_from']>>> class Shape:...     def __dir__(self):...         return ['area', 'perimeter', 'location']>>> s = Shape()>>> dir(s)['area', 'location', 'perimeter']
```

注解

因为 [`dir()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#dir) 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。



`divmod`(*a*, *b*)

以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 `(a // b, a % b)` 相同。对于浮点数则结果为``(q, a % b)``，其中 *q* 通常为 `math.floor(a / b)`，但可能比它小 1。在任何情况下，`q * b + a % b` 都非常接近 *a*，如果 `a % b` 非零，则结果符号与 *b* 相同，并且 `0 <= abs(a % b) < abs(b)`。



`enumerate`(*iterable*, *start=0*)

返回一个枚举对象。*iterable* 必须是一个序列，或 [iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterator)，或其他支持迭代的对象。 [`enumerate()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#enumerate) 返回的迭代器的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法返回一个元组，里面包含一个计数值（从 *start* 开始，默认为 0）和通过迭代 *iterable* 获得的值。

```
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
```

等价于:

```
def enumerate(sequence, start=0):    n = start    for elem in sequence:        yield n, elem        n += 1
```



# E

`eval`(*expression*[, *globals*[, *locals*]])

实参是一个字符串，以及可选的 globals 和 locals。*globals* 实参必须是一个字典。*locals* 可以是任何映射对象。

表达式解析参数 *expression* 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 *globals* 和 *locals* 字典作为全局和局部命名空间。 如果存在 *globals* 字典，并且不包含 `__builtins__` 键的值，则在解析 *expression* 之前会插入以该字符串为键以对内置模块 [`builtins`](https://www.bookstack.cn/read/python-3.10.0-zh/081707c85e5c8af0.md#module-builtins) 的字典的引用为值的项。 这样就可以在将 *globals* 传给 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 之前通过向其传入你自己的 `__builtins__` 字典来控制可供被执行代码可以使用哪些内置模块。 如果 *locals* 字典被省略则它默认为 *globals* 字典。 如果两个字典都被省略，则将使用调用 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 的环境中的 *globals* 和 *locals* 来执行该表达式。 注意，*eval()* 无法访问闭包环境中的 [嵌套作用域](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-nested-scope) (非局部变量)。

返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：

```
>>> x = 1
>>> eval('x+1')
2
```

该函数还可用于执行任意代码对象（比如由 [`compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#compile) 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为 *mode* 的 `'exec'` 进行了编译，那么 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 的返回值将为 `None`。

提示： [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数支持语句的动态执行。 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 和 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数分别返回当前的全局和本地字典，可供传给 [`eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#eval) 或 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 使用。

如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。

另外可以参阅 [`ast.literal_eval()`](https://www.bookstack.cn/read/python-3.10.0-zh/6c0f2df9b9fb0f96.md#ast.literal_eval)，该函数可以安全执行仅包含文字的表达式字符串。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `exec` 附带参数 `code_object`



`exec`(*object*[, *globals*[, *locals*]])

这个函数支持动态执行 Python 代码。 *object* 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 [1](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id2) 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的“文件输入”一节）。 请注意即使在传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数的代码的上下文中，[`nonlocal`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#nonlocal), [`yield`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#yield) 和 [`return`](https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#return) 语句也不能在函数定义以外使用。 该函数的返回值是 `None`。

无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 *globals*，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 *globals* 和 *locals*，则将分别用于全局变量和局部变量。*locals* 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 *globals* 和 *locals*，代码执行起来就像嵌入到某个类定义中一样。

如果 *globals* 字典不包含 `__builtins__` 键值，则将为该键插入对内建 [`builtins`](https://www.bookstack.cn/read/python-3.10.0-zh/081707c85e5c8af0.md#module-builtins) 模块字典的引用。因此，在将执行的代码传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 之前，可以通过将自己的 `__builtins__` 字典插入到 *globals* 中来控制可以使用哪些内置代码。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `exec` 附带参数 `code_object`。

注解

内置 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 和 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数各自返回当前的全局和本地字典，因此可以将它们传递给 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 的第二个和第三个实参。

注解

默认情况下，*locals* 的行为如下面 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 函数描述的一样：不要试图改变默认的 *locals* 字典。如果您想在 [`exec()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#exec) 函数返回时知道代码对 *locals* 的变动，请明确地传递 *locals* 字典。



# F

`filter`(*function*, *iterable*)

用 *iterable* 中函数 *function* 返回真的那些元素，构建一个新的迭代器。*iterable* 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 *function* 是 `None` ，则会假设它是一个身份函数，即 *iterable* 中所有返回假的元素会被移除。

请注意， `filter(function, iterable)` 相当于一个生成器表达式，当 function 不是 `None` 的时候为 `(item for item in iterable if function(item))`；function 是 `None` 的时候为 `(item for item in iterable if item)` 。

请参阅 [`itertools.filterfalse()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.filterfalse) 了解，只有 *function* 返回 false 时才选取 *iterable* 中元素的补充函数。



*class* `float`([*x*])

返回从数字或字符串 *x* 生成的浮点数。

如果参数是个字符串，则应包含一个十进制数字，前面可选带上符号，也可选前后带有空白符。符号可以是``‘+’`` 或 `'-'`；`'+'` 符号对值没有影响。参数也可以是一个代表 NaN（非数字）或正负无穷大的字符串。更确切地说，在去除前导和尾部的空白符后，输入参数必须符合以下语法：

~~~python
sign           ::=  "+" | "-"
infinity       ::=  "Infinity" | "inf"
nan            ::=  "nan"
numeric_value  ::=  floatnumber | infinity | nan
numeric_string ::=  [sign] numeric_value
~~~

这里的 `floatnumber` 是指 Python 的浮点数格式，在 [浮点数字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#floating) 中有介绍。大小写没有关系，所以“inf”、“Inf”、“INFINITY”、“iNfINity”都可接受为正无穷的拼写形式。

另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。

对于一个普通 Python 对象 `x`，`float(x)` 会委托给 `x.__float__()`。 如果 `__float__()` 未定义则将回退至 `__index__()`。

如果没有实参，则返回 `0.0` 。



`format`(*value*[, *format_spec*])

将 *value* 转换为“格式化后”的形式，格式由 *format_spec* 进行控制。*format_spec* 的解释方式取决于 *value* 参数的类型；但大多数内置类型使用一种标准的格式化语法： [格式规格迷你语言](https://www.bookstack.cn/read/python-3.10.0-zh/1cb7b20c32bbf2f2.md#formatspec)。

默认的 *format_spec* 是一个空字符串，它通常给出与调用 [`str(value)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str) 相同的结果。

调用 `format(value, format_spec)` 会转换成 `type(value).__format__(value, format_spec)` ，所以实例字典中的 `__format__()` 方法将不会调用。如果方法搜索回退到 [`object`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object) 类但 *format_spec* 不为空，或者如果 *format_spec* 或返回值不是字符串，则会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

在 3.4 版更改: 当 *format_spec* 不是空字符串时， `object().__format__(format_spec)` 会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。



*class* `frozenset`([*iterable*])

返回一个新的 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 对象，它包含可选参数 *iterable* 中的元素。 `frozenset` 是一个内置的类。有关此类的文档，请参阅 [`frozenset`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#frozenset) 和 [集合类型 —- set, frozenset](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-set)。

请参阅内建的 [`set`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#set)、[`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list)、[`tuple`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#tuple) 和 [`dict`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#dict) 类，以及 [`collections`](https://www.bookstack.cn/read/python-3.10.0-zh/a4dd9fbea64da53a.md#module-collections) 模块来了解其它的容器。



# G

`getattr`(*object*, *name*[, *default*])

返回对象命名属性的值。*name* 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， `getattr(x, 'foobar')` 等同于 `x.foobar`。如果指定的属性不存在，且提供了 *default* 值，则返回它，否则触发 [`AttributeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#AttributeError)。

注解

由于 [私有名称混合](https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#private-name-mangling) 发生在编译时，因此必须 手动混合私有属性（以两个下划线打头的属性）名称以使使用 [`getattr()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#getattr) 来提取它。



`globals`()

返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。



# H

`hasattr`(*object*, *name*)

该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 `True`，否则返回 `False`。（此功能是通过调用 `getattr(object, name)` 看是否有 [`AttributeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#AttributeError) 异常来实现的。）



`hash`(*object*)

返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。

注解

如果对象实现了自己的 `__hash__()` 方法，请注意，[`hash()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#hash) 根据机器的字长来截断返回值。另请参阅 `__hash__()`。



`help`([*object*])

启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。

请注意，如果在调用 [`help()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#help) 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。详情请参阅 [有关仅限位置形参的 FAQ 条目](https://www.bookstack.cn/read/python-3.10.0-zh/0c13e3b82cdf8d41.md#faq-positional-only-arguments)。

该函数通过 [`site`](https://www.bookstack.cn/read/python-3.10.0-zh/45534d8b6c7003d0.md#module-site) 模块加入到内置命名空间。

在 3.4 版更改: [`pydoc`](https://www.bookstack.cn/read/python-3.10.0-zh/cce4aac0b84df460.md#module-pydoc) 和 [`inspect`](https://www.bookstack.cn/read/python-3.10.0-zh/996a92025b483010.md#module-inspect) 的变更使得可调用对象的签名信息更加全面和一致。



`hex`(*x*)

将整数转换为以“0x”为前缀的小写十六进制字符串。如果 *x* 不是 Python [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 对象，则必须定义返回整数的 `__index__()` 方法。一些例子：

~~~python
>>> hex(255)
'0xff'
>>> hex(-42)
'-0x2a'
~~~



# I

`id`(*object*)

返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 [`id()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#id) 值。



`input`([*prompt*])

如果存在 *prompt* 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 [`EOFError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#EOFError)。例如:

~~~python
>>> s = input('--> ')  
--> Monty Python's Flying Circus
>>> s  
"Monty Python's Flying Circus"
~~~

如果加载了 [`readline`](https://www.bookstack.cn/read/python-3.10.0-zh/4702d003cd17da61.md#module-readline) 模块，[`input()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#input) 将使用它来提供复杂的行编辑和历史记录功能。

引发一个 [审计事件](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#auditing) `builtins.input` 附带参数 `prompt`。

在成功读取输入之后引发一个审计事件 `builtins.input/result` 附带结果。



*class* `int`([*x*])

*class* `int`(*x*, *base=10*)

返回一个基于数字或字符串 *x* 构造的整数对象，或者在未给出参数时返回 `0`。 如果 *x* 定义了 `__int__()`，`int(x)` 将返回 `x.__int__()`。 如果 *x* 定义了 `__index__()`，它将返回 `x.__index__()`。 如果 *x* 定义了 `__trunc__()`，它将返回 `x.__trunc__()`。 对于浮点数，它将向零舍入。

如果 *x* 不是数字，或者有 *base* 参数，*x* 必须是字符串、[`bytes`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytes)、表示进制为 *base* 的 [整数字面值](https://www.bookstack.cn/read/python-3.10.0-zh/946caea9cab3fb99.md#integers) 的 [`bytearray`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#bytearray) 实例。该文字前可以有 `+` 或 `-` （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 `a` 到 `z` （或 `A` 到 `Z` ）表示 10 到 35。默认的 *base* 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 `0b`/`0B` 、 `0o`/`0O` 、 `0x`/`0X` 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 `int('010', 0)` 是非法的，但 `int('010')` 和 `int('010', 8)` 是合法的。

整数类型定义请参阅 [数字类型 —- int, float, complex](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesnumeric) 。

在 3.4 版更改: 如果 *base* 不是 [`int`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int) 的实例，但 *base* 对象有 [`base.__index__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__) 方法，则会调用该方法来获取进制数。以前的版本使用 [`base.__int__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__int__) 而不是 [`base.__index__`](https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#object.__index__)。

在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。

在 3.7 版更改: *x* 现在只能作为位置参数。

在 3.8 版更改: 如果 `__int__()` 未定义则回退至 `__index__()`。



`isinstance`(*object*, *classinfo*)

如果 *object* 参数是 *classinfo* 参数的实例，或其（直接、间接或 [virtual](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class) ）子类的实例，则返回 `True`。 如果 *object* 不是给定类型的对象，则总是返回 `False`。如果 *classinfo* 是类型对象的元组（或由该类元组递归生成）或多个类型的 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)，那么当 *object* 是其中任一类型的实例时就会返回 `True`。如果 *classinfo* 不是某个类型或类型元组，将会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) 异常。

在 3.10 版更改: *classinfo* 可以是一个 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)。



`issubclass`(*class*, *classinfo*)

Return `True` if *class* is a subclass (direct, indirect, or [virtual](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-abstract-base-class)) of *classinfo*. A class is considered a subclass of itself. *classinfo* may be a tuple of class objects or a [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union), in which case return `True` if *class* is a subclass of any entry in *classinfo*. In any other case, a [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError) exception is raised.

在 3.10 版更改: *classinfo* 可以是一个 [Union Type](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#types-union)。



`iter`(*object*[, *sentinel*])

返回一个 [iterator](https://www.bookstack.cn/read/python-3.10.0-zh/bd6b000ceb39b61e.md#term-iterator) 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，*object* 必须是支持迭代协议（有 `__iter__()` 方法）的集合对象，或必须支持序列协议（有 `__getitem__()` 方法，且数字参数从 `0` 开始）。如果它不支持这些协议，会触发 [`TypeError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TypeError)。如果有第二个实参 *sentinel*，那么 *object* 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 [`__next__()`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#iterator.__next__) 方法时都会不带实参地调用 *object*；如果返回的结果是 *sentinel* 则触发 [`StopIteration`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#StopIteration)，否则返回调用结果。

另请参阅 [迭代器类型](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typeiter)。

适合 [`iter()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#iter) 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:





`len`(*s*)

返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。

**CPython implementation detail:** `len` 对于大于 [`sys.maxsize`](https://www.bookstack.cn/read/python-3.10.0-zh/bea00e6431e98893.md#sys.maxsize) 的长度如 [`range(2 ** 100)`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#range) 会引发 [`OverflowError`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#OverflowError)。



*class* `list`([*iterable*])

虽然被称为函数，[`list`](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#list) 实际上是一种可变序列类型，详情请参阅 [列表](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq-list) 和 [序列类型 —- list, tuple, range](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typesseq)。



`locals`()

更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 [`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 时将返回自由变量。 请注意在模块层级上，[`locals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#locals) 和 [`globals()`](https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#globals) 是同一个字典。



`map`(*function*, *iterable*, *…*)

返回一个将 *function* 应用于 *iterable* 中每一项并输出其结果的迭代器。 如果传入了额外的 *iterable* 参数，*function* 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况，请参阅 [`itertools.starmap()`](https://www.bookstack.cn/read/python-3.10.0-zh/d230b7788e5c2742.md#itertools.starmap)。





*class* `memoryview`(*object*)

返回由给定实参创建的“内存视图”对象。有关详细信息，请参阅 [内存视图](https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#typememoryview)。