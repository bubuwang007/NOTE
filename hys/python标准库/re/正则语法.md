正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。

正则表达式可以拼接；如果 *A* 和 *B* 都是正则表达式，则 *AB* 也是正则表达式。通常，如果字符串 *p* 匹配 *A*，并且另一个字符串 *q* 匹配 *B*，那么 *pq* 可以匹配 AB。除非 *A* 或者 *B* 包含低优先级操作，*A* 和 *B* 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。更多正则表达式理论和实现，详见 the Friedl book [[Frie09\]](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#frie09) ，或者其他构建编译器的书籍。



# 简单规则介绍

## 匹配简单字符

正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 `'A'`, `'a'`, 或者 `'0'`，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 `last` 匹配字符串 `'last'`. （在这一节的其他部分，我们将用 `this special style` 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 `'in single quotes'` ，单引号形式。）



## 特殊字符

有些字符，比如 `'|'` 或者 `'('`，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。

重复修饰符 (`*`, `+`, `?`, `{m,n}`, 等) 不能直接嵌套。这样避免了非贪婪后缀 `?` 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 `(?:a{6})*` 匹配6个 `'a'` 字符重复任意次数。

特殊字符有：

```
.
```

(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 [`DOTALL`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.DOTALL) ，它将匹配包括换行符的任意字符。

```
^
```

(插入符号) 匹配字符串的开头， 并且在 [`MULTILINE`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.MULTILINE) 模式也匹配换行后的首个符号。

```
$
```

匹配字符串尾或者在字符串尾的换行符的前一个字符，在 [`MULTILINE`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.MULTILINE) 模式下也会匹配换行符之前的文本。 `foo` 匹配 ‘foo’ 和 ‘foobar’，但正则表达式 `foo$` 只匹配 ‘foo’。 更有趣的是，在 `'foo1\nfoo2\n'` 中搜索 `foo.$`，通常匹配 ‘foo2’，但在 [`MULTILINE`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.MULTILINE) 模式下可以匹配到 ‘foo1’；在 `'foo\n'` 中搜索 `$` 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。

```
*
```

对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 `ab*` 会匹配 `'a'`，`'ab'`，或者 `'a'` 后面跟随任意个 `'b'`。

```
+
```

对它前面的正则式匹配1到任意次重复。 `ab+` 会匹配 `'a'` 后面跟随1个以上到任意个 `'b'`，它不会匹配 `'a'`。

```
?
```

对它前面的正则式匹配0到1次重复。 `ab?` 会匹配 `'a'` 或者 `'ab'`。

```
*?, +?, ??
```

`'*'`, `'+'`，和 `'?'` 修饰符都是 *贪婪的*；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 `<.*>` 希望找到 `'<a> b <c>'`，它将会匹配整个字符串，而不仅是 `'<a>'`。在修饰符之后添加 `?` 将使样式以 *非贪婪方式或者 :dfn:最小* 方式进行匹配； 尽量 *少* 的字符将会被匹配。 使用正则式 `<.*?>` 将会仅仅匹配 `'<a>'`。

```
{m}
```

对其之前的正则式指定匹配 *m* 个重复；少于 *m* 的话就会导致匹配失败。比如， `a{6}` 将匹配6个 `'a'` , 但是不能是5个。

```
{m,n}
```

对正则式进行 *m* 到 *n* 次匹配，在 *m* 和 *n* 之间取尽量多。 比如，`a{3,5}` 将匹配 3 到 5个 `'a'`。忽略 *m* 意为指定下界为0，忽略 *n* 指定上界为无限次。 比如 `a{4,}b` 将匹配 `'aaaab'` 或者1000个 `'a'` 尾随一个 `'b'`，但不能匹配 `'aaab'`。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。

```
{m,n}?
```

前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 `'aaaaaa'`， `a{3,5}` 匹配 5个 `'a'` ，而 `a{3,5}?` 只匹配3个 `'a'`。

```
\
```

转义特殊字符（允许你匹配 `'*'`, `'?'`, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。

如果你没有使用原始字符串（ `r'raw'` ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。

```
[]
```

用于表示一个字符集合。在一个集合中：

- 字符可以单独列出，比如 `[amk]` 匹配 `'a'`， `'m'`， 或者 `'k'`。
- 可以表示字符范围，通过用 `'-'` 将两个字符连起来。比如 `[a-z]` 将匹配任何小写ASCII字符， `[0-5][0-9]` 将匹配从 `00` 到 `59` 的两位数字， `[0-9A-Fa-f]` 将匹配任何十六进制数位。 如果 `-` 进行了转义 （比如 `[a\-z]`）或者它的位置在首位或者末尾（如 `[-a]` 或 `[a-]`），它就只表示普通字符 `'-'`。
- 特殊字符在集合中，失去它的特殊含义。比如 `[(+*)]` 只会匹配这几个文法字符 `'('`, `'+'`, `'*'`, or `')'`。
- 字符类如 `\w` 或者 `\S` (如下定义) 在集合内可以接受，它们可以匹配的字符由 [`ASCII`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.ASCII) 或者 [`LOCALE`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.LOCALE) 模式决定。
- 不在集合范围内的字符可以通过 *取反* 来进行匹配。如果集合首字符是 `'^'` ，所有 *不* 在集合内的字符将会被匹配，比如 `[^5]` 将匹配所有字符，除了 `'5'`， `[^^]` 将匹配所有字符，除了 `'^'`. `^` 如果不在集合首位，就没有特殊含义。
- 在集合内要匹配一个字符 `']'`，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， `[()[\]{}]` 和 `[]()[{}]` 都可以匹配括号。
- [Unicode Technical Standard #18](https://unicode.org/reports/tr18/) 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 [`FutureWarning`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#FutureWarning) 将会在有多义的情况里被 `raise`，包含以下几种情况，集合由 `'['` 开始，或者包含下列字符序列 `'--'`, `'&&'`, `'~~'`, 和 `'||'`。为了避免警告，需要将它们用反斜杠转义。

在 3.7 版更改: 如果一个字符串构建的语义在未来会改变的话，一个 [`FutureWarning`](https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#FutureWarning) 会 `raise` 。

```
|
```

`A|B`， *A* 和 *B* 可以是任意正则表达式，创建一个正则表达式，匹配 *A* 或者 *B*. 任意个正则表达式可以用 `'|'` 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， `'|'` 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 *A* 匹配成功， *B* 就不再进行匹配，即便它能产生一个更好的匹配。或者说，`'|'` 操作符绝不贪婪。 如果要匹配 `'|'` 字符，使用 `\|`， 或者把它包含在字符集里，比如 `[|]`.

```
(...)
```

（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 `\number` 转义序列进行再次匹配，之后进行详细说明。要匹配字符 `'('` 或者 `')'`, 用 `\(` 或 `\)`, 或者把它们包含在字符集合里: `[(]`, `[)]`.



```
(?…)
```

这是个扩展标记法 （一个 `'?'` 跟随 `'('` 并无含义）。 `'?'` 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； `(?P<name>...)` 是唯一的例外。 以下是目前支持的扩展。

```
(?aiLmsux)
```

( `'a'`, `'i'`, `'L'`, `'m'`, `'s'`, `'u'`, `'x'` 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 [`re.A`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.A) (只匹配ASCII字符), [`re.I`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.I) (忽略大小写), [`re.L`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.L) (语言依赖), [`re.M`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.M) (多行模式), [`re.S`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.S) (点dot匹配全部字符), `re.U` (Unicode匹配), and [`re.X`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.X) (冗长模式)。 (这些标记在 [模块内容](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#contents-of-module-re) 中描述) 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 [`re.compile()`](https://www.bookstack.cn/read/python-3.10.0-zh/868c2e547f2c81e9.md#re.compile) 中传递 *flag* 参数。标记应该在表达式字符串首位表示。



